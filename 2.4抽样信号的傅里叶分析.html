<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æŠ½æ ·ä¿¡å·çš„å‚…é‡Œå¶åˆ†æ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 50%, #43e97b 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
            padding: 30px;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        h2 {
            color: #34495e;
            border-left: 4px solid #4facfe;
            padding-left: 15px;
            margin-top: 40px;
        }
        
        h3 {
            color: #00f2fe;
            margin-top: 25px;
        }
        
        .section {
            margin-bottom: 40px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .formula {
            background: #e3f7ff;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Times New Roman', serif;
            font-size: 1.1em;
            margin: 15px 0;
            border-left: 4px solid #4facfe;
            text-align: center;
        }
        
        .theorem-box {
            background: #e8f8f5;
            border: 2px solid #43e97b;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .theorem-box h4 {
            color: #27ae60;
            margin-top: 0;
            font-size: 1.3em;
        }
        
        .canvas-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
        }
        
        .signal-canvas {
            border: 2px solid #bdc3c7;
            border-radius: 8px;
            background: white;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        
        .controls {
            background: #f0f8ff;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid #4facfe;
        }
        
        .controls label {
            margin-right: 15px;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .controls input, .controls select {
            margin: 5px;
            padding: 5px 10px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
        }
        
        button {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 5px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }
        
        .warning-button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
        }
        
        .warning-button:hover {
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        
        .exercise {
            background: #fff8e1;
            border: 1px solid #ffcc02;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .exercise h4 {
            color: #f57f17;
            margin-top: 0;
        }
        
        .answer-input {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 4px;
            margin: 10px;
            width: 200px;
        }
        
        .feedback {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .correct {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .incorrect {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .key-points {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .key-points h4 {
            color: #0d47a1;
            margin-top: 0;
        }
        
        .sampling-demo {
            background: #f3e5f5;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px solid #9c27b0;
        }
        
        .aliasing-demo {
            background: #ffebee;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px solid #f44336;
        }
        
        .reconstruction-demo {
            background: #e8f5e8;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px solid #4caf50;
        }
        
        .spectrum-display {
            font-family: monospace;
            background: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #ddd;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .triple-view {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            align-items: start;
        }
        
        .dual-view {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            align-items: start;
        }
        
        ul li {
            margin: 8px 0;
        }
        
        .highlight {
            background: #ffeb3b;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .warning h5 {
            color: #856404;
            margin-top: 0;
        }
        
        .sampling-rate-indicator {
            background: #e1f5fe;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }
        
        .adequate {
            background: #c8e6c9;
            color: #2e7d32;
        }
        
        .inadequate {
            background: #ffcdd2;
            color: #c62828;
        }
        
        .critical {
            background: #fff3e0;
            color: #ef6c00;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ“Š æŠ½æ ·ä¿¡å·çš„å‚…é‡Œå¶åˆ†æ</h1>
        
        <div class="section">
            <h2>1. æ—¶åŸŸæŠ½æ ·çš„åŸºæœ¬æ¦‚å¿µ</h2>
            
            <h3>1.1 æŠ½æ ·çš„å®šä¹‰</h3>
            <div class="key-points">
                <h4>æŠ½æ ·è¿‡ç¨‹ï¼š</h4>
                <ul>
                    <li><strong>è¿ç»­ä¿¡å· â†’ ç¦»æ•£ä¿¡å·</strong>ï¼šä»è¿ç»­æ—¶é—´ä¿¡å·ä¸­æŒ‰ä¸€å®šæ—¶é—´é—´éš”å–å€¼</li>
                    <li><strong>æŠ½æ ·å‘¨æœŸTs</strong>ï¼šç›¸é‚»ä¸¤ä¸ªæŠ½æ ·ç‚¹çš„æ—¶é—´é—´éš”</li>
                    <li><strong>æŠ½æ ·é¢‘ç‡fs = 1/Ts</strong>ï¼šæ¯ç§’æŠ½æ ·çš„æ¬¡æ•°</li>
                    <li><strong>æ•°å­—åŒ–ç¬¬ä¸€æ­¥</strong>ï¼šæ¨¡æ‹Ÿä¿¡å·å¤„ç†çš„åŸºç¡€</li>
                </ul>
            </div>
            
            <h3>1.2 ç†æƒ³æŠ½æ ·çš„æ•°å­¦æè¿°</h3>
            <div class="formula">
                æŠ½æ ·ä¿¡å·ï¼šxs(t) = x(t) Â· âˆ‘_{n=-âˆ}^{âˆ} Î´(t - nTs)<br><br>
                ç¦»æ•£åºåˆ—ï¼šx[n] = x(nTs), n = 0, Â±1, Â±2, ...
            </div>
            
            <div class="sampling-demo">
                <h4>æŠ½æ ·è¿‡ç¨‹å¯è§†åŒ–</h4>
                <div class="controls">
                    <label>åŸå§‹ä¿¡å·:</label>
                    <select id="originalSignal" onchange="updateSamplingDemo()">
                        <option value="sine">æ­£å¼¦æ³¢</option>
                        <option value="cosine">ä½™å¼¦æ³¢</option>
                        <option value="complex">å¤åˆä¿¡å·</option>
                        <option value="chirp">çº¿æ€§è°ƒé¢‘</option>
                    </select>
                    <label>ä¿¡å·é¢‘ç‡fm:</label>
                    <input type="range" id="signalFreq" min="0.5" max="10" step="0.5" value="2">
                    <span id="signalFreqValue">2</span> Hz
                    <label>æŠ½æ ·é¢‘ç‡fs:</label>
                    <input type="range" id="samplingFreq" min="1" max="50" step="1" value="10">
                    <span id="samplingFreqValue">10</span> Hz
                    <button onclick="updateSamplingDemo()">æ›´æ–°æ¼”ç¤º</button>
                    <button onclick="animateSampling()">åŠ¨ç”»æ¼”ç¤º</button>
                </div>
                
                <div class="sampling-rate-indicator" id="samplingIndicator">
                    æŠ½æ ·ç‡åˆ†æå°†åœ¨è¿™é‡Œæ˜¾ç¤º
                </div>
                
                <div class="canvas-container">
                    <canvas id="samplingTimeCanvas" class="signal-canvas" width="700" height="300"></canvas>
                    <canvas id="samplingSpectrumCanvas" class="signal-canvas" width="700" height="300"></canvas>
                </div>
                <div id="samplingAnalysis" class="spectrum-display">æŠ½æ ·åˆ†æç»“æœ</div>
            </div>
            
            <div class="exercise">
                <h4>ğŸ”§ ç»ƒä¹ é¢˜1ï¼š</h4>
                <p>å¯¹é¢‘ç‡ä¸º5Hzçš„æ­£å¼¦ä¿¡å·è¿›è¡ŒæŠ½æ ·ï¼Œè‡³å°‘éœ€è¦å¤šé«˜çš„æŠ½æ ·é¢‘ç‡æ‰èƒ½é¿å…æ··å ï¼Ÿ</p>
                <input type="number" id="answer1" class="answer-input" placeholder="è¾“å…¥é¢‘ç‡(Hz)" step="0.1">
                <button onclick="checkAnswer1()">æäº¤ç­”æ¡ˆ</button>
                <div id="feedback1" class="feedback" style="display:none;"></div>
            </div>
        </div>
        
        <div class="section">
            <h2>2. æŠ½æ ·å®šç†ï¼ˆå¥ˆå¥æ–¯ç‰¹å®šç†ï¼‰</h2>
            
            <div class="theorem-box">
                <h4>ğŸ¯ å¥ˆå¥æ–¯ç‰¹æŠ½æ ·å®šç†</h4>
                <div class="formula">
                    <strong>æ¡ä»¶ï¼š</strong>å¦‚æœè¿ç»­ä¿¡å·x(t)æ˜¯å¸¦é™çš„ï¼Œå³X(jÏ‰) = 0, |Ï‰| > Ï‰m<br>
                    <strong>ç»“è®ºï¼š</strong>å½“æŠ½æ ·é¢‘ç‡fs â‰¥ 2fmæ—¶ï¼Œå¯ä»¥ä»æŠ½æ ·ä¿¡å·å®Œå…¨é‡æ„åŸä¿¡å·<br>
                    <strong>å…³é”®ï¼š</strong>Ï‰s = 2Ï€/Ts â‰¥ 2Ï‰mï¼Œå³fs â‰¥ 2fm
                </div>
                <p><strong>å¥ˆå¥æ–¯ç‰¹é¢‘ç‡ï¼š</strong>fN = 2fmï¼ˆæœ€ä½æŠ½æ ·é¢‘ç‡ï¼‰</p>
                <p><strong>å¥ˆå¥æ–¯ç‰¹ç‡ï¼š</strong>æ¯ç§’è‡³å°‘æŠ½æ ·2fmæ¬¡</p>
            </div>
            
            <h3>2.1 æŠ½æ ·å®šç†çš„é¢‘åŸŸè§£é‡Š</h3>
            <div class="formula">
                æŠ½æ ·ä¿¡å·çš„é¢‘è°±ï¼šXs(jÏ‰) = (1/Ts) âˆ‘_{k=-âˆ}^{âˆ} X(j(Ï‰ - kÏ‰s))<br><br>
                é¢‘è°±å‘¨æœŸæ€§å»¶æ‹“ï¼Œå‘¨æœŸä¸ºÏ‰s = 2Ï€/Ts
            </div>
            
            <div class="aliasing-demo">
                <h4>æŠ½æ ·å®šç†éªŒè¯ä¸æ··å æ¼”ç¤º</h4>
                <div class="controls">
                    <label>ä¿¡å·ç±»å‹:</label>
                    <select id="theoremSignal" onchange="updateTheoremDemo()">
                        <option value="bandlimited">ç†æƒ³å¸¦é™ä¿¡å·</option>
                        <option value="sinc">sincè„‰å†²</option>
                        <option value="gaussian">é«˜æ–¯è„‰å†²</option>
                    </select>
                    <label>ä¿¡å·å¸¦å®½fm:</label>
                    <input type="range" id="signalBandwidth" min="1" max="10" step="0.5" value="3">
                    <span id="signalBandwidthValue">3</span> Hz
                    <label>æŠ½æ ·ç‡å€æ•°:</label>
                    <input type="range" id="samplingRatio" min="0.5" max="5" step="0.1" value="2.5">
                    <span id="samplingRatioValue">2.5</span> Ã— 2fm
                    <button onclick="updateTheoremDemo()">æ›´æ–°æ¼”ç¤º</button>
                </div>
                
                <div class="triple-view">
                    <div>
                        <canvas id="originalSpectrumCanvas" class="signal-canvas" width="400" height="250"></canvas>
                        <p style="text-align: center;"><strong>åŸä¿¡å·é¢‘è°±</strong></p>
                    </div>
                    <div>
                        <canvas id="sampledSpectrumCanvas" class="signal-canvas" width="400" height="250"></canvas>
                        <p style="text-align: center;"><strong>æŠ½æ ·åé¢‘è°±</strong></p>
                    </div>
                    <div>
                        <canvas id="aliasingCanvas" class="signal-canvas" width="400" height="250"></canvas>
                        <p style="text-align: center;"><strong>æ··å åˆ†æ</strong></p>
                    </div>
                </div>
                <div id="theoremAnalysis" class="spectrum-display">å®šç†éªŒè¯ç»“æœ</div>
            </div>
            
            <div class="warning">
                <h5>âš ï¸ æ··å ç°è±¡ï¼ˆAliasingï¼‰</h5>
                <p><strong>äº§ç”Ÿæ¡ä»¶ï¼š</strong>fs < 2fmï¼ˆè¿åæŠ½æ ·å®šç†ï¼‰</p>
                <p><strong>ç°è±¡ï¼š</strong>é«˜é¢‘åˆ†é‡è¢«è¯¯è®¤ä¸ºä½é¢‘åˆ†é‡</p>
                <p><strong>åæœï¼š</strong>ä¿¡æ¯ä¸¢å¤±ï¼Œæ— æ³•å®Œå…¨é‡æ„åŸä¿¡å·</p>
                <p><strong>é¿å…æ–¹æ³•ï¼š</strong>æé«˜æŠ½æ ·ç‡æˆ–ä½¿ç”¨æŠ—æ··å æ»¤æ³¢å™¨</p>
            </div>
            
            <div class="exercise">
                <h4>ğŸ”§ ç»ƒä¹ é¢˜2ï¼š</h4>
                <p>ä¸€ä¸ªä¿¡å·åŒ…å«1Hzã€3Hzã€5Hzä¸‰ä¸ªé¢‘ç‡åˆ†é‡ï¼Œç”¨8Hzè¿›è¡ŒæŠ½æ ·ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ</p>
                <select id="answer2" class="answer-input">
                    <option value="">é€‰æ‹©ç­”æ¡ˆ</option>
                    <option value="no_aliasing">ä¸ä¼šæ··å </option>
                    <option value="aliasing_5hz">5Hzåˆ†é‡ä¼šæ··å </option>
                    <option value="aliasing_35hz">3Hzå’Œ5Hzéƒ½ä¼šæ··å </option>
                </select>
                <button onclick="checkAnswer2()">æäº¤ç­”æ¡ˆ</button>
                <div id="feedback2" class="feedback" style="display:none;"></div>
            </div>
        </div>
        
        <div class="section">
            <h2>3. ä¿¡å·é‡æ„ä¸æ’å€¼</h2>
            
            <h3>3.1 ç†æƒ³é‡æ„å…¬å¼</h3>
            <div class="formula">
                ç†æƒ³é‡æ„ï¼šx(t) = âˆ‘_{n=-âˆ}^{âˆ} x(nTs) Â· sinc((t - nTs)/Ts)<br><br>
                å…¶ä¸­ï¼šsinc(x) = sin(Ï€x)/(Ï€x)
            </div>
            
            <h3>3.2 é‡æ„çš„æ¡ä»¶</h3>
            <div class="key-points">
                <h4>å®Œç¾é‡æ„çš„è¦æ±‚ï¼š</h4>
                <ul>
                    <li><strong>ä¿¡å·å¸¦é™</strong>ï¼šX(jÏ‰) = 0, |Ï‰| > Ï‰m</li>
                    <li><strong>æŠ½æ ·ç‡è¶³å¤Ÿ</strong>ï¼šfs â‰¥ 2fm</li>
                    <li><strong>ç†æƒ³ä½é€šæ»¤æ³¢</strong>ï¼šæˆªæ­¢é¢‘ç‡Ï‰c = Ï‰m</li>
                    <li><strong>æ— é™é•¿sincå‡½æ•°</strong>ï¼šå®é™…ä¸­ä¸å¯å®ç°</li>
                </ul>
            </div>
            
            <div class="reconstruction-demo">
                <h4>ä¿¡å·é‡æ„æ¼”ç¤º</h4>
                <div class="controls">
                    <label>é‡æ„æ–¹æ³•:</label>
                    <select id="reconstructionMethod" onchange="updateReconstructionDemo()">
                        <option value="ideal">ç†æƒ³é‡æ„(sinc)</option>
                        <option value="zoh">é›¶é˜¶ä¿æŒ</option>
                        <option value="linear">çº¿æ€§æ’å€¼</option>
                        <option value="cubic">ä¸‰æ¬¡æ ·æ¡</option>
                    </select>
                    <label>æŠ½æ ·ç‚¹æ•°:</label>
                    <input type="range" id="sampleCount" min="5" max="50" step="5" value="20">
                    <span id="sampleCountValue">20</span>
                    <label>sincæˆªæ–­é•¿åº¦:</label>
                    <input type="range" id="sincLength" min="5" max="50" step="5" value="20">
                    <span id="sincLengthValue">20</span>
                    <button onclick="updateReconstructionDemo()">æ›´æ–°é‡æ„</button>
                </div>
                
                <div class="dual-view">
                    <div>
                        <canvas id="reconstructionCanvas" class="signal-canvas" width="600" height="350"></canvas>
                        <p style="text-align: center;"><strong>æ—¶åŸŸé‡æ„å¯¹æ¯”</strong></p>
                    </div>
                    <div>
                        <canvas id="reconstructionErrorCanvas" class="signal-canvas" width="600" height="350"></canvas>
                        <p style="text-align: center;"><strong>é‡æ„è¯¯å·®åˆ†æ</strong></p>
                    </div>
                </div>
                <div id="reconstructionAnalysis" class="spectrum-display">é‡æ„è´¨é‡åˆ†æ</div>
            </div>
            
            <div class="exercise">
                <h4>ğŸ”§ ç»ƒä¹ é¢˜3ï¼š</h4>
                <p>ç†æƒ³é‡æ„ä½¿ç”¨çš„æ’å€¼å‡½æ•°æ˜¯ä»€ä¹ˆï¼Ÿ</p>
                <select id="answer3" class="answer-input">
                    <option value="">é€‰æ‹©ç­”æ¡ˆ</option>
                    <option value="sinc">sincå‡½æ•°</option>
                    <option value="rect">çŸ©å½¢å‡½æ•°</option>
                    <option value="triangle">ä¸‰è§’å‡½æ•°</option>
                </select>
                <button onclick="checkAnswer3()">æäº¤ç­”æ¡ˆ</button>
                <div id="feedback3" class="feedback" style="display:none;"></div>
            </div>
        </div>
        
        <div class="section">
            <h2>4. å®é™…æŠ½æ ·çš„è€ƒè™‘å› ç´ </h2>
            
            <h3>4.1 å®é™…ä¿¡å·çš„ç‰¹ç‚¹</h3>
            <div class="warning">
                <h5>å®é™…æŒ‘æˆ˜ï¼š</h5>
                <ul>
                    <li><strong>ä¿¡å·ä¸æ˜¯ä¸¥æ ¼å¸¦é™çš„</strong>ï¼šæ€»æœ‰é«˜é¢‘åˆ†é‡å­˜åœ¨</li>
                    <li><strong>æŠ—æ··å æ»¤æ³¢å™¨</strong>ï¼šæŠ½æ ·å‰å¿…é¡»è¿›è¡Œä½é€šæ»¤æ³¢</li>
                    <li><strong>é‡åŒ–è¯¯å·®</strong>ï¼šADCçš„ä½æ•°é™åˆ¶</li>
                    <li><strong>æŠ½æ ·æ—¶é’ŸæŠ–åŠ¨</strong>ï¼šæŠ½æ ·æ—¶åˆ»çš„ä¸å‡†ç¡®æ€§</li>
                </ul>
            </div>
            
            <h3>4.2 æŠ—æ··å æ»¤æ³¢å™¨è®¾è®¡</h3>
            <div class="formula">
                æ»¤æ³¢å™¨è¦æ±‚ï¼š<br>
                â€¢ é€šå¸¦ï¼š|H(jÏ‰)| â‰ˆ 1, |Ï‰| â‰¤ Ï‰m<br>
                â€¢ é˜»å¸¦ï¼š|H(jÏ‰)| â‰ˆ 0, |Ï‰| â‰¥ Ï‰s/2 - Ï‰m<br>
                â€¢ è¿‡æ¸¡å¸¦ï¼šÏ‰m < |Ï‰| < Ï‰s/2 - Ï‰m
            </div>
            
            <div class="sampling-demo">
                <h4>å®é™…æŠ½æ ·ç³»ç»Ÿæ¼”ç¤º</h4>
                <div class="controls">
                    <label>è¾“å…¥ä¿¡å·:</label>
                    <select id="realSignal" onchange="updateRealSamplingDemo()">
                        <option value="music">éŸ³ä¹ä¿¡å·æ¨¡æ‹Ÿ</option>
                        <option value="speech">è¯­éŸ³ä¿¡å·æ¨¡æ‹Ÿ</option>
                        <option value="noisy">å«å™ªå£°ä¿¡å·</option>
                    </select>
                    <label>æŠ—æ··å æ»¤æ³¢:</label>
                    <select id="antiAliasFilter" onchange="updateRealSamplingDemo()">
                        <option value="none">æ— æ»¤æ³¢</option>
                        <option value="ideal">ç†æƒ³æ»¤æ³¢</option>
                        <option value="butterworth">å·´ç‰¹æ²ƒæ–¯æ»¤æ³¢</option>
                    </select>
                    <label>æŠ½æ ·ç‡:</label>
                    <input type="range" id="realSamplingRate" min="8000" max="48000" step="1000" value="16000">
                    <span id="realSamplingRateValue">16000</span> Hz
                    <button onclick="updateRealSamplingDemo()">æ›´æ–°æ¼”ç¤º</button>
                </div>
                
                <div class="canvas-container">
                    <canvas id="realInputCanvas" class="signal-canvas" width="500" height="200"></canvas>
                    <canvas id="realFilteredCanvas" class="signal-canvas" width="500" height="200"></canvas>
                    <canvas id="realSampledCanvas" class="signal-canvas" width="500" height="200"></canvas>
                </div>
                <div id="realSamplingAnalysis" class="spectrum-display">å®é™…æŠ½æ ·åˆ†æ</div>
            </div>
            
            <h3>4.3 å¸¸è§æŠ½æ ·æ ‡å‡†</h3>
            <div class="key-points">
                <h4>å·¥ç¨‹åº”ç”¨ä¸­çš„æŠ½æ ·ç‡ï¼š</h4>
                <ul>
                    <li><strong>ç”µè¯éŸ³è´¨</strong>ï¼š8 kHzï¼ˆè¯­éŸ³å¸¦å®½â‰ˆ3.4 kHzï¼‰</li>
                    <li><strong>CDéŸ³è´¨</strong>ï¼š44.1 kHzï¼ˆéŸ³é¢‘å¸¦å®½â‰ˆ20 kHzï¼‰</li>
                    <li><strong>DVDéŸ³è´¨</strong>ï¼š48 kHz æˆ– 96 kHz</li>
                    <li><strong>ä¸“ä¸šéŸ³é¢‘</strong>ï¼š192 kHz</li>
                    <li><strong>ä¸ºä»€ä¹ˆ44.1kï¼Ÿ</strong>ï¼š20 kHz Ã— 2.205 â‰ˆ 44.1 kHz</li>
                </ul>
            </div>
            
            <div class="exercise">
                <h4>ğŸ”§ ç»ƒä¹ é¢˜4ï¼š</h4>
                <p>CDéŸ³è´¨é‡‡ç”¨44.1kHzæŠ½æ ·ç‡ï¼Œè¿™æ ·è®¾è®¡çš„ä¸»è¦åŸå› æ˜¯ä»€ä¹ˆï¼Ÿ</p>
                <select id="answer4" class="answer-input">
                    <option value="">é€‰æ‹©ç­”æ¡ˆ</option>
                    <option value="human_hearing">äººè€³å¬è§‰èŒƒå›´çº¦20kHz</option>
                    <option value="technical_limit">å½“æ—¶æŠ€æœ¯é™åˆ¶</option>
                    <option value="storage_cost">å­˜å‚¨æˆæœ¬è€ƒè™‘</option>
                </select>
                <button onclick="checkAnswer4()">æäº¤ç­”æ¡ˆ</button>
                <div id="feedback4" class="feedback" style="display:none;"></div>
            </div>
        </div>
        
        <div class="section">
            <h2>5. æ•°å­—ä¿¡å·å¤„ç†ç®€ä»‹</h2>
            
            <h3>5.1 ä»æ¨¡æ‹Ÿåˆ°æ•°å­—</h3>
            <div class="key-points">
                <h4>A/Dè½¬æ¢è¿‡ç¨‹ï¼š</h4>
                <ul>
                    <li><strong>1. æŠ—æ··å æ»¤æ³¢</strong>ï¼šå»é™¤é«˜é¢‘å¹²æ‰°</li>
                    <li><strong>2. æŠ½æ ·</strong>ï¼šæ—¶é—´ç¦»æ•£åŒ–</li>
                    <li><strong>3. é‡åŒ–</strong>ï¼šå¹…åº¦ç¦»æ•£åŒ–</li>
                    <li><strong>4. ç¼–ç </strong>ï¼šè½¬æ¢ä¸ºæ•°å­—åºåˆ—</li>
                </ul>
            </div>
            
            <h3>5.2 æ•°å­—ä¿¡å·çš„ä¼˜åŠ¿</h3>
            <div class="formula">
                ä¼˜åŠ¿ï¼š<br>
                â€¢ ç²¾ç¡®æ€§ï¼šé¿å…æ¨¡æ‹Ÿç”µè·¯çš„æ¼‚ç§»<br>
                â€¢ çµæ´»æ€§ï¼šè½¯ä»¶å®ç°ï¼Œæ˜“äºä¿®æ”¹<br>
                â€¢ å¯é‡å¤æ€§ï¼šæ•°å­—å¤„ç†ç»“æœä¸€è‡´<br>
                â€¢ å¤æ‚ç®—æ³•ï¼šå¯å®ç°å¤æ‚çš„å¤„ç†ç®—æ³•
            </div>
            
            <div class="sampling-demo">
                <h4>ADC/DACè¿‡ç¨‹æ¨¡æ‹Ÿ</h4>
                <div class="controls">
                    <label>ADCä½æ•°:</label>
                    <select id="adcBits" onchange="updateADCDemo()">
                        <option value="4">4ä½</option>
                        <option value="8">8ä½</option>
                        <option value="12">12ä½</option>
                        <option value="16">16ä½</option>
                    </select>
                    <label>æŠ½æ ·ç‡:</label>
                    <input type="range" id="adcSamplingRate" min="10" max="100" step="10" value="40">
                    <span id="adcSamplingRateValue">40</span> Hz
                    <button onclick="updateADCDemo()">æ›´æ–°æ¼”ç¤º</button>
                </div>
                
                <div class="canvas-container">
                    <canvas id="adcOriginalCanvas" class="signal-canvas" width="600" height="250"></canvas>
                    <canvas id="adcQuantizedCanvas" class="signal-canvas" width="600" height="250"></canvas>
                </div>
                <div id="adcAnalysis" class="spectrum-display">ADCæ€§èƒ½åˆ†æ</div>
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸ“ æœ¬ç« å°ç»“</h2>
            <div class="key-points">
                <h4>æ ¸å¿ƒè¦ç‚¹ï¼š</h4>
                <ul>
                    <li><strong>æŠ½æ ·å®šç†</strong>ï¼šfs â‰¥ 2fmï¼Œè¿æ¥è¿ç»­å’Œç¦»æ•£ä¿¡å·çš„æ¡¥æ¢</li>
                    <li><strong>æ··å ç°è±¡</strong>ï¼šè¿åæŠ½æ ·å®šç†çš„åæœï¼Œä¸å¯é€†è½¬</li>
                    <li><strong>ä¿¡å·é‡æ„</strong>ï¼šç†æƒ³é‡æ„éœ€è¦sincæ’å€¼</li>
                    <li><strong>å®é™…è€ƒè™‘</strong>ï¼šæŠ—æ··å æ»¤æ³¢ã€é‡åŒ–è¯¯å·®ã€å·¥ç¨‹æƒè¡¡</li>
                    <li><strong>åº”ç”¨æ„ä¹‰</strong>ï¼šæ•°å­—ä¿¡å·å¤„ç†çš„ç†è®ºåŸºç¡€</li>
                </ul>
            </div>
            
            <div class="theorem-box">
                <h4>ğŸ“š é‡è¦å…¬å¼æ€»ç»“</h4>
                <div class="formula">
                    1. æŠ½æ ·å®šç†ï¼šfs â‰¥ 2fm<br>
                    2. é¢‘è°±å‘¨æœŸå»¶æ‹“ï¼šXs(jÏ‰) = (1/Ts)âˆ‘X(j(Ï‰-kÏ‰s))<br>
                    3. ç†æƒ³é‡æ„ï¼šx(t) = âˆ‘x(nTs)sinc((t-nTs)/Ts)<br>
                    4. å¥ˆå¥æ–¯ç‰¹é¢‘ç‡ï¼šfN = 2fm
                </div>
            </div>
            
            <div class="exercise">
                <h4>ğŸ¯ ç»¼åˆç»ƒä¹ ï¼š</h4>
                <p>ä¸€ä¸ªè¯­éŸ³ä¿¡å·çš„æœ€é«˜é¢‘ç‡ä¸º4kHzï¼Œç°è¦æ±‚é‡æ„è¯¯å·®å°äº1%ï¼Œåº”è¯¥é€‰æ‹©å¤šé«˜çš„æŠ½æ ·é¢‘ç‡ï¼Ÿ</p>
                <input type="number" id="answer5" class="answer-input" placeholder="è¾“å…¥é¢‘ç‡(kHz)" step="0.1">
                <button onclick="checkAnswer5()">æäº¤ç­”æ¡ˆ</button>
                <div id="feedback5" class="feedback" style="display:none;"></div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let animationId;
        const colors = {
            primary: '#4facfe',
            secondary: '#00f2fe', 
            accent: '#43e97b',
            success: '#27ae60',
            warning: '#f39c12',
            danger: '#e74c3c',
            info: '#3498db',
            purple: '#9c27b0'
        };
        
        // æ•°å­¦å·¥å…·å‡½æ•°
        function sinc(x) {
            return (Math.abs(x) < 1e-10) ? 1 : Math.sin(Math.PI * x) / (Math.PI * x);
        }
        
        function generateSignal(type, t, freq, params = {}) {
            switch(type) {
                case 'sine':
                    return Math.sin(2 * Math.PI * freq * t);
                case 'cosine':
                    return Math.cos(2 * Math.PI * freq * t);
                case 'complex':
                    return Math.sin(2 * Math.PI * freq * t) + 0.3 * Math.sin(2 * Math.PI * 3 * freq * t);
                case 'chirp':
                    return Math.sin(2 * Math.PI * freq * t * (1 + 0.5 * t));
                case 'bandlimited':
                    // æ¨¡æ‹Ÿå¸¦é™ä¿¡å·
                    return sinc(2 * freq * t) * Math.cos(2 * Math.PI * freq * t / 3);
                case 'sinc':
                    return sinc(2 * freq * t);
                case 'gaussian':
                    return Math.exp(-(freq * t) * (freq * t));
                default:
                    return 0;
            }
        }
        
        // ç»˜å›¾å·¥å…·å‡½æ•°
        function drawAxis(ctx, width, height, xLabel = 't', yLabel = 'x(t)', showGrid = true) {
            ctx.clearRect(0, 0, width, height);
            
            if (showGrid) {
                ctx.strokeStyle = '#f0f0f0';
                ctx.lineWidth = 0.5;
                for (let i = 40; i < width - 40; i += 20) {
                    ctx.beginPath();
                    ctx.moveTo(i, 20);
                    ctx.lineTo(i, height - 20);
                    ctx.stroke();
                }
                for (let i = 20; i < height - 20; i += 20) {
                    ctx.beginPath();
                    ctx.moveTo(40, i);
                    ctx.lineTo(width - 40, i);
                    ctx.stroke();
                }
            }
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Xè½´
            ctx.beginPath();
            ctx.moveTo(40, centerY);
            ctx.lineTo(width - 40, centerY);
            ctx.stroke();
            
            // Yè½´
            ctx.beginPath();
            ctx.moveTo(centerX, 20);
            ctx.lineTo(centerX, height - 20);
            ctx.stroke();
            
            // æ ‡ç­¾
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText(xLabel, width - 30, centerY + 20);
            ctx.fillText(yLabel, centerX + 10, 35);
            ctx.fillText('0', centerX + 5, centerY + 15);
        }
        
        function drawFrequencyAxis(ctx, width, height, maxFreq = 10) {
            ctx.clearRect(0, 0, width, height);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            const centerX = width / 2;
            const centerY = height - 40;
            
            // Xè½´ï¼ˆé¢‘ç‡è½´ï¼‰
            ctx.beginPath();
            ctx.moveTo(40, centerY);
            ctx.lineTo(width - 40, centerY);
            ctx.stroke();
            
            // Yè½´ï¼ˆå¹…åº¦è½´ï¼‰
            ctx.beginPath();
            ctx.moveTo(centerX, 20);
            ctx.lineTo(centerX, centerY);
            ctx.stroke();
            
            // æ ‡ç­¾
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText('f (Hz)', width - 30, centerY + 20);
            ctx.fillText('|X(f)|', centerX + 10, 35);
            ctx.fillText('0', centerX - 5, centerY + 15);
            
            // é¢‘ç‡åˆ»åº¦
            const freqScale = (width - 80) / (2 * maxFreq);
            for (let f = -maxFreq; f <= maxFreq; f += maxFreq/5) {
                if (f !== 0) {
                    const x = centerX + f * freqScale;
                    ctx.beginPath();
                    ctx.moveTo(x, centerY - 5);
                    ctx.lineTo(x, centerY + 5);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#666';
                    ctx.font = '10px Arial';
                    ctx.fillText(f.toFixed(0), x - 5, centerY + 18);
                }
            }
        }
        
        // æŠ½æ ·æ¼”ç¤º
        function updateSamplingDemo() {
            const signalType = document.getElementById('originalSignal').value;
            const fm = parseFloat(document.getElementById('signalFreq').value);
            const fs = parseFloat(document.getElementById('samplingFreq').value);
            
            document.getElementById('signalFreqValue').textContent = fm;
            document.getElementById('samplingFreqValue').textContent = fs;
            
            const timeCanvas = document.getElementById('samplingTimeCanvas');
            const spectrumCanvas = document.getElementById('samplingSpectrumCanvas');
            const timeCtx = timeCanvas.getContext('2d');
            const spectrumCtx = spectrumCanvas.getContext('2d');
            
            // ç»˜åˆ¶æ—¶åŸŸå›¾
            drawAxis(timeCtx, 700, 300, 't (s)', 'x(t)');
            drawSamplingTimeSignal(timeCtx, signalType, fm, fs);
            
            // ç»˜åˆ¶é¢‘åŸŸå›¾
            drawFrequencyAxis(spectrumCtx, 700, 300, Math.max(15, fs));
            drawSamplingSpectrum(spectrumCtx, signalType, fm, fs);
            
            // æ›´æ–°åˆ†æ
            updateSamplingIndicator(fm, fs);
            analyzeSampling(signalType, fm, fs);
        }
        
        function drawSamplingTimeSignal(ctx, signalType, fm, fs) {
            const centerX = 350;
            const centerY = 150;
            const scaleX = 100;
            const scaleY = 80;
            const Ts = 1 / fs;
            
            // ç»˜åˆ¶è¿ç»­ä¿¡å·
            ctx.strokeStyle = colors.info;
            ctx.lineWidth = 2;
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            
            let first = true;
            for (let t = -3; t <= 3; t += 0.01) {
                const y = generateSignal(signalType, t, fm);
                const x = centerX + t * scaleX;
                const plotY = centerY - y * scaleY;
                
                if (first) {
                    ctx.moveTo(x, plotY);
                    first = false;
                } else {
                    ctx.lineTo(x, plotY);
                }
            }
            ctx.stroke();
            ctx.setLineDash([]);
            
            // ç»˜åˆ¶æŠ½æ ·ç‚¹
            ctx.fillStyle = colors.danger;
            ctx.strokeStyle = colors.danger;
            ctx.lineWidth = 2;
            
            for (let n = Math.floor(-3 * fs); n <= Math.ceil(3 * fs); n++) {
                const t = n * Ts;
                if (Math.abs(t) <= 3) {
                    const y = generateSignal(signalType, t, fm);
                    const x = centerX + t * scaleX;
                    const plotY = centerY - y * scaleY;
                    
                    // æŠ½æ ·ç‚¹
                    ctx.beginPath();
                    ctx.arc(x, plotY, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // å‚ç›´çº¿
                    ctx.beginPath();
                    ctx.moveTo(x, centerY);
                    ctx.lineTo(x, plotY);
                    ctx.stroke();
                }
            }
            
            // å›¾ä¾‹
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.fillText('åŸä¿¡å·(è™šçº¿)', 50, 30);
            ctx.fillText('æŠ½æ ·ç‚¹(çº¢ç‚¹)', 150, 30);
        }
        
        function drawSamplingSpectrum(ctx, signalType, fm, fs) {
            const centerX = 350;
            const centerY = 260;
            const freqScale = 20;
            const ampScale = 100;
            
            // ç»˜åˆ¶åŸä¿¡å·é¢‘è°±
            ctx.strokeStyle = colors.info;
            ctx.lineWidth = 2;
            drawOriginalSpectrum(ctx, signalType, fm, centerX, centerY, freqScale, ampScale);
            
            // ç»˜åˆ¶æŠ½æ ·åçš„é¢‘è°±ï¼ˆå‘¨æœŸå»¶æ‹“ï¼‰
            ctx.strokeStyle = colors.danger;
            ctx.lineWidth = 2;
            for (let k = -2; k <= 2; k++) {
                drawShiftedSpectrum(ctx, signalType, fm, k * fs, centerX, centerY, freqScale, ampScale);
            }
            
            // æ ‡è®°æ··å åŒºåŸŸ
            if (fs < 2 * fm) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                const aliasingStart = centerX + (fs/2 - fm) * freqScale;
                const aliasingEnd = centerX + (fs/2 + fm) * freqScale;
                ctx.fillRect(aliasingStart, 20, aliasingEnd - aliasingStart, centerY - 20);
            }
        }
        
        function drawOriginalSpectrum(ctx, signalType, fm, centerX, centerY, freqScale, ampScale) {
            ctx.beginPath();
            
            switch(signalType) {
                case 'sine':
                case 'cosine':
                    // å•ä¸€é¢‘ç‡çš„å†²æ¿€
                    const x1 = centerX - fm * freqScale;
                    const x2 = centerX + fm * freqScale;
                    ctx.moveTo(x1, centerY);
                    ctx.lineTo(x1, centerY - ampScale * 0.5);
                    ctx.moveTo(x2, centerY);
                    ctx.lineTo(x2, centerY - ampScale * 0.5);
                    break;
                    
                case 'complex':
                    // å¤šä¸ªé¢‘ç‡åˆ†é‡
                    for (let f of [fm, 3*fm]) {
                        const x1 = centerX - f * freqScale;
                        const x2 = centerX + f * freqScale;
                        const amp = (f === fm) ? 0.5 : 0.15;
                        ctx.moveTo(x1, centerY);
                        ctx.lineTo(x1, centerY - ampScale * amp);
                        ctx.moveTo(x2, centerY);
                        ctx.lineTo(x2, centerY - ampScale * amp);
                    }
                    break;
                    
                case 'bandlimited':
                    // å¸¦é™ä¿¡å·çš„çŸ©å½¢é¢‘è°±
                    const width = fm * freqScale;
                    ctx.rect(centerX - width, centerY - ampScale * 0.5, 2 * width, ampScale * 0.5);
                    break;
            }
            ctx.stroke();
        }
        
        function drawShiftedSpectrum(ctx, signalType, fm, shift, centerX, centerY, freqScale, ampScale) {
            ctx.save();
            ctx.translate(shift * freqScale, 0);
            drawOriginalSpectrum(ctx, signalType, fm, centerX, centerY, freqScale, ampScale * 0.3);
            ctx.restore();
        }
        
        function updateSamplingIndicator(fm, fs) {
            const indicator = document.getElementById('samplingIndicator');
            const nyquistRate = 2 * fm;
            
            if (fs >= nyquistRate * 1.2) {
                indicator.textContent = `âœ… æŠ½æ ·ç‡å……è¶³: fs = ${fs}Hz > 2fm = ${nyquistRate}Hz`;
                indicator.className = 'sampling-rate-indicator adequate';
            } else if (fs >= nyquistRate) {
                indicator.textContent = `âš ï¸ ä¸´ç•ŒæŠ½æ ·: fs = ${fs}Hz â‰ˆ 2fm = ${nyquistRate}Hz`;
                indicator.className = 'sampling-rate-indicator critical';
            } else {
                indicator.textContent = `âŒ æŠ½æ ·ä¸è¶³: fs = ${fs}Hz < 2fm = ${nyquistRate}Hz (ä¼šäº§ç”Ÿæ··å !)`;
                indicator.className = 'sampling-rate-indicator inadequate';
            }
        }
        
        function analyzeSampling(signalType, fm, fs) {
            const analysis = document.getElementById('samplingAnalysis');
            const nyquistRate = 2 * fm;
            
            let result = `<strong>æŠ½æ ·åˆ†æç»“æœ:</strong><br>`;
            result += `ä¿¡å·æœ€é«˜é¢‘ç‡: ${fm} Hz<br>`;
            result += `æŠ½æ ·é¢‘ç‡: ${fs} Hz<br>`;
            result += `å¥ˆå¥æ–¯ç‰¹ç‡: ${nyquistRate} Hz<br>`;
            result += `æŠ½æ ·å‘¨æœŸ: ${(1/fs).toFixed(3)} s<br><br>`;
            
            if (fs >= nyquistRate) {
                result += `âœ… æ»¡è¶³æŠ½æ ·å®šç†ï¼Œå¯ä»¥å®Œå…¨é‡æ„åŸä¿¡å·<br>`;
                result += `é¢‘è°±æ— é‡å ï¼Œæ— æ··å å¤±çœŸ`;
            } else {
                result += `âŒ è¿åæŠ½æ ·å®šç†ï¼Œå‘ç”Ÿé¢‘è°±æ··å <br>`;
                result += `é«˜é¢‘åˆ†é‡ ${fm} Hz ä¼šæ··å åˆ° ${Math.abs(fs - fm)} Hz`;
            }
            
            analysis.innerHTML = result;
        }
        
        // æŠ½æ ·å®šç†éªŒè¯æ¼”ç¤º
        function updateTheoremDemo() {
            const signalType = document.getElementById('theoremSignal').value;
            const bandwidth = parseFloat(document.getElementById('signalBandwidth').value);
            const ratio = parseFloat(document.getElementById('samplingRatio').value);
            
            document.getElementById('signalBandwidthValue').textContent = bandwidth;
            document.getElementById('samplingRatioValue').textContent = ratio;
            
            const fs = ratio * 2 * bandwidth;
            
            const originalCanvas = document.getElementById('originalSpectrumCanvas');
            const sampledCanvas = document.getElementById('sampledSpectrumCanvas');
            const aliasingCanvas = document.getElementById('aliasingCanvas');
            
            const originalCtx = originalCanvas.getContext('2d');
            const sampledCtx = sampledCanvas.getContext('2d');
            const aliasingCtx = aliasingCanvas.getContext('2d');
            
            // ç»˜åˆ¶åŸä¿¡å·é¢‘è°±
            drawFrequencyAxis(originalCtx, 400, 250, bandwidth * 3);
            drawBandlimitedSpectrum(originalCtx, signalType, bandwidth);
            
            // ç»˜åˆ¶æŠ½æ ·åé¢‘è°±
            drawFrequencyAxis(sampledCtx, 400, 250, fs);
            drawSampledSpectrum(sampledCtx, signalType, bandwidth, fs);
            
            // åˆ†ææ··å 
            drawFrequencyAxis(aliasingCtx, 400, 250, fs);
            analyzeAliasing(aliasingCtx, signalType, bandwidth, fs);
            
            // æ›´æ–°åˆ†æç»“æœ
            analyzeTheoremDemo(signalType, bandwidth, fs, ratio);
        }
        
        function drawBandlimitedSpectrum(ctx, signalType, bandwidth) {
            const centerX = 200;
            const centerY = 210;
            const freqScale = 15;
            const ampScale = 80;
            
            ctx.fillStyle = colors.info;
            ctx.strokeStyle = colors.info;
            ctx.lineWidth = 2;
            
            switch(signalType) {
                case 'bandlimited':
                    // ç†æƒ³çŸ©å½¢é¢‘è°±
                    const width = bandwidth * freqScale;
                    ctx.fillRect(centerX - width, centerY - ampScale, 2 * width, ampScale);
                    break;
                    
                case 'sinc':
                    // sincå‡½æ•°çš„é¢‘è°±ï¼ˆçŸ©å½¢ï¼‰
                    const sincWidth = bandwidth * freqScale;
                    ctx.fillRect(centerX - sincWidth, centerY - ampScale, 2 * sincWidth, ampScale);
                    break;
                    
                case 'gaussian':
                    // é«˜æ–¯å‡½æ•°çš„é¢‘è°±ï¼ˆé«˜æ–¯å½¢ï¼‰
                    ctx.beginPath();
                    for (let f = -bandwidth * 2; f <= bandwidth * 2; f += 0.1) {
                        const x = centerX + f * freqScale;
                        const amplitude = Math.exp(-(f/bandwidth) * (f/bandwidth));
                        const y = centerY - amplitude * ampScale;
                        
                        if (f === -bandwidth * 2) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    break;
            }
        }
        
        function drawSampledSpectrum(ctx, signalType, bandwidth, fs) {
            const centerX = 200;
            const centerY = 210;
            const freqScale = 5;
            
            // ç»˜åˆ¶å‘¨æœŸå»¶æ‹“çš„é¢‘è°±
            for (let k = -3; k <= 3; k++) {
                ctx.save();
                ctx.translate(k * fs * freqScale, 0);
                ctx.globalAlpha = (k === 0) ? 1 : 0.6;
                drawBandlimitedSpectrum(ctx, signalType, bandwidth);
                ctx.restore();
            }
        }
        
        function analyzeAliasing(ctx, signalType, bandwidth, fs) {
            const centerX = 200;
            const centerY = 210;
            
            if (fs < 2 * bandwidth) {
                // ç»˜åˆ¶æ··å åŒºåŸŸ
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.fillRect(50, 50, 300, 160);
                
                ctx.fillStyle = colors.danger;
                ctx.font = '14px Arial';
                ctx.fillText('æ··å åŒºåŸŸ', centerX - 30, centerY - 100);
                ctx.fillText(`fs < 2fm`, centerX - 30, centerY - 80);
            } else {
                ctx.fillStyle = colors.success;
                ctx.font = '14px Arial';
                ctx.fillText('æ— æ··å ', centerX - 20, centerY - 100);
                ctx.fillText(`fs â‰¥ 2fm`, centerX - 20, centerY - 80);
            }
        }
        
        function analyzeTheoremDemo(signalType, bandwidth, fs, ratio) {
            const analysis = document.getElementById('theoremAnalysis');
            
            let result = `<strong>æŠ½æ ·å®šç†éªŒè¯:</strong><br>`;
            result += `ä¿¡å·å¸¦å®½: ${bandwidth} Hz<br>`;
            result += `æŠ½æ ·é¢‘ç‡: ${fs.toFixed(1)} Hz<br>`;
            result += `æŠ½æ ·ç‡å€æ•°: ${ratio} Ã— 2fm<br><br>`;
            
            if (ratio >= 1) {
                result += `âœ… æ»¡è¶³æŠ½æ ·å®šç† (fs â‰¥ 2fm)<br>`;
                result += `å¯ä»¥å®Œå…¨é‡æ„åŸä¿¡å·<br>`;
                result += `é¢‘è°±æ— é‡å æ··å `;
            } else {
                result += `âŒ è¿åæŠ½æ ·å®šç† (fs < 2fm)<br>`;
                result += `å‘ç”Ÿé¢‘è°±æ··å <br>`;
                result += `ä¿¡æ¯ä¸¢å¤±ï¼Œæ— æ³•å®Œå…¨é‡æ„`;
            }
            
            analysis.innerHTML = result;
        }
        
        // é‡æ„æ¼”ç¤º
        function updateReconstructionDemo() {
            const method = document.getElementById('reconstructionMethod').value;
            const sampleCount = parseInt(document.getElementById('sampleCount').value);
            const sincLength = parseInt(document.getElementById('sincLength').value);
            
            document.getElementById('sampleCountValue').textContent = sampleCount;
            document.getElementById('sincLengthValue').textContent = sincLength;
            
            const reconstructionCanvas = document.getElementById('reconstructionCanvas');
            const errorCanvas = document.getElementById('reconstructionErrorCanvas');
            const reconstructionCtx = reconstructionCanvas.getContext('2d');
            const errorCtx = errorCanvas.getContext('2d');
            
            // ç»˜åˆ¶é‡æ„å¯¹æ¯”
            drawAxis(reconstructionCtx, 600, 350, 't', 'x(t)');
            drawReconstructionComparison(reconstructionCtx, method, sampleCount, sincLength);
            
            // ç»˜åˆ¶è¯¯å·®åˆ†æ
            drawAxis(errorCtx, 600, 350, 't', 'è¯¯å·®');
            drawReconstructionError(errorCtx, method, sampleCount, sincLength);
            
            // åˆ†æé‡æ„è´¨é‡
            analyzeReconstructionQuality(method, sampleCount, sincLength);
        }
        
        function drawReconstructionComparison(ctx, method, sampleCount, sincLength) {
            const centerX = 300;
            const centerY = 175;
            const scaleX = 80;
            const scaleY = 60;
            const fm = 2;
            const fs = 10;
            const Ts = 1 / fs;
            
            // ç»˜åˆ¶åŸä¿¡å·
            ctx.strokeStyle = colors.info;
            ctx.lineWidth = 2;
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            
            let first = true;
            for (let t = -3; t <= 3; t += 0.01) {
                const y = Math.sin(2 * Math.PI * fm * t);
                const x = centerX + t * scaleX;
                const plotY = centerY - y * scaleY;
                
                if (first) {
                    ctx.moveTo(x, plotY);
                    first = false;
                } else {
                    ctx.lineTo(x, plotY);
                }
            }
            ctx.stroke();
            ctx.setLineDash([]);
            
            // ç»˜åˆ¶æŠ½æ ·ç‚¹
            ctx.fillStyle = colors.danger;
            const samples = [];
            for (let n = -sampleCount/2; n <= sampleCount/2; n++) {
                const t = n * Ts;
                if (Math.abs(t) <= 3) {
                    const y = Math.sin(2 * Math.PI * fm * t);
                    const x = centerX + t * scaleX;
                    const plotY = centerY - y * scaleY;
                    
                    ctx.beginPath();
                    ctx.arc(x, plotY, 3, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    samples.push({t, y});
                }
            }
            
            // ç»˜åˆ¶é‡æ„ä¿¡å·
            ctx.strokeStyle = colors.success;
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            first = true;
            for (let t = -3; t <= 3; t += 0.02) {
                const y = reconstructSignal(t, samples, method, Ts, sincLength);
                const x = centerX + t * scaleX;
                const plotY = centerY - y * scaleY;
                
                if (first) {
                    ctx.moveTo(x, plotY);
                    first = false;
                } else {
                    ctx.lineTo(x, plotY);
                }
            }
            ctx.stroke();
            
            // å›¾ä¾‹
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.fillText('åŸä¿¡å·(è™šçº¿)', 50, 30);
            ctx.fillText('æŠ½æ ·ç‚¹(çº¢)', 150, 30);
            ctx.fillText('é‡æ„ä¿¡å·(ç»¿)', 250, 30);
        }
        
        function reconstructSignal(t, samples, method, Ts, sincLength) {
            let result = 0;
            
            switch(method) {
                case 'ideal':
                    // ç†æƒ³é‡æ„ï¼ˆsincæ’å€¼ï¼‰
                    for (let sample of samples) {
                        if (Math.abs(sample.t) <= sincLength * Ts / 2) {
                            result += sample.y * sinc((t - sample.t) / Ts);
                        }
                    }
                    break;
                    
                case 'zoh':
                    // é›¶é˜¶ä¿æŒ
                    for (let i = 0; i < samples.length - 1; i++) {
                        if (t >= samples[i].t && t < samples[i + 1].t) {
                            result = samples[i].y;
                            break;
                        }
                    }
                    break;
                    
                case 'linear':
                    // çº¿æ€§æ’å€¼
                    for (let i = 0; i < samples.length - 1; i++) {
                        if (t >= samples[i].t && t <= samples[i + 1].t) {
                            const ratio = (t - samples[i].t) / (samples[i + 1].t - samples[i].t);
                            result = samples[i].y + ratio * (samples[i + 1].y - samples[i].y);
                            break;
                        }
                    }
                    break;
                    
                case 'cubic':
                    // ç®€åŒ–çš„ä¸‰æ¬¡æ’å€¼
                    result = linearInterpolation(t, samples);
                    break;
            }
            
            return result;
        }
        
        function linearInterpolation(t, samples) {
            for (let i = 0; i < samples.length - 1; i++) {
                if (t >= samples[i].t && t <= samples[i + 1].t) {
                    const ratio = (t - samples[i].t) / (samples[i + 1].t - samples[i].t);
                    return samples[i].y + ratio * (samples[i + 1].y - samples[i].y);
                }
            }
            return 0;
        }
        
        function drawReconstructionError(ctx, method, sampleCount, sincLength) {
            const centerX = 300;
            const centerY = 175;
            const scaleX = 80;
            const scaleY = 200;
            const fm = 2;
            const fs = 10;
            const Ts = 1 / fs;
            
            // ç”ŸæˆæŠ½æ ·ç‚¹
            const samples = [];
            for (let n = -sampleCount/2; n <= sampleCount/2; n++) {
                const t = n * Ts;
                if (Math.abs(t) <= 3) {
                    const y = Math.sin(2 * Math.PI * fm * t);
                    samples.push({t, y});
                }
            }
            
            // ç»˜åˆ¶è¯¯å·®æ›²çº¿
            ctx.strokeStyle = colors.danger;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            let first = true;
            let maxError = 0;
            
            for (let t = -3; t <= 3; t += 0.02) {
                const original = Math.sin(2 * Math.PI * fm * t);
                const reconstructed = reconstructSignal(t, samples, method, Ts, sincLength);
                const error = original - reconstructed;
                
                maxError = Math.max(maxError, Math.abs(error));
                
                const x = centerX + t * scaleX;
                const plotY = centerY - error * scaleY;
                
                if (first) {
                    ctx.moveTo(x, plotY);
                    first = false;
                } else {
                    ctx.lineTo(x, plotY);
                }
            }
            ctx.stroke();
            
            // æ˜¾ç¤ºæœ€å¤§è¯¯å·®
            ctx.fillStyle = colors.danger;
            ctx.font = '14px Arial';
            ctx.fillText(`æœ€å¤§è¯¯å·®: ${maxError.toFixed(3)}`, 50, 30);
        }
        
        function analyzeReconstructionQuality(method, sampleCount, sincLength) {
            const analysis = document.getElementById('reconstructionAnalysis');
            
            let result = `<strong>é‡æ„è´¨é‡åˆ†æ:</strong><br>`;
            result += `é‡æ„æ–¹æ³•: ${method}<br>`;
            result += `æŠ½æ ·ç‚¹æ•°: ${sampleCount}<br>`;
            
            switch(method) {
                case 'ideal':
                    result += `sincæˆªæ–­é•¿åº¦: ${sincLength}<br>`;
                    result += `ä¼˜ç‚¹: ç†è®ºä¸Šå®Œç¾é‡æ„<br>`;
                    result += `ç¼ºç‚¹: éœ€è¦æ— é™é•¿sincå‡½æ•°`;
                    break;
                case 'zoh':
                    result += `ä¼˜ç‚¹: å®ç°ç®€å•ï¼Œå®æ—¶æ€§å¥½<br>`;
                    result += `ç¼ºç‚¹: é«˜é¢‘åˆ†é‡æŸå¤±ä¸¥é‡`;
                    break;
                case 'linear':
                    result += `ä¼˜ç‚¹: è®¡ç®—ç®€å•ï¼Œè¿ç»­æ€§å¥½<br>`;
                    result += `ç¼ºç‚¹: é«˜é¢‘å“åº”æœ‰é™`;
                    break;
                case 'cubic':
                    result += `ä¼˜ç‚¹: å¹³æ»‘æ€§å¥½<br>`;
                    result += `ç¼ºç‚¹: è®¡ç®—å¤æ‚åº¦è¾ƒé«˜`;
                    break;
            }
            
            analysis.innerHTML = result;
        }
        
        // å®é™…æŠ½æ ·ç³»ç»Ÿæ¼”ç¤º
        function updateRealSamplingDemo() {
            const signalType = document.getElementById('realSignal').value;
            const filterType = document.getElementById('antiAliasFilter').value;
            const samplingRate = parseInt(document.getElementById('realSamplingRate').value);
            
            document.getElementById('realSamplingRateValue').textContent = samplingRate;
            
            const inputCanvas = document.getElementById('realInputCanvas');
            const filteredCanvas = document.getElementById('realFilteredCanvas');
            const sampledCanvas = document.getElementById('realSampledCanvas');
            
            const inputCtx = inputCanvas.getContext('2d');
            const filteredCtx = filteredCanvas.getContext('2d');
            const sampledCtx = sampledCanvas.getContext('2d');
            
            // ç»˜åˆ¶å„é˜¶æ®µä¿¡å·
            drawAxis(inputCtx, 500, 200, 't', 'è¾“å…¥');
            drawRealSignal(inputCtx, signalType);
            
            drawAxis(filteredCtx, 500, 200, 't', 'æ»¤æ³¢å');
            drawFilteredSignal(filteredCtx, signalType, filterType);
            
            drawAxis(sampledCtx, 500, 200, 't', 'æŠ½æ ·å');
            drawSampledSignal(sampledCtx, signalType, filterType, samplingRate);
            
            analyzeRealSampling(signalType, filterType, samplingRate);
        }
        
        function drawRealSignal(ctx, signalType) {
            ctx.strokeStyle = colors.primary;
            ctx.lineWidth = 2;
            
            const centerX = 250;
            const centerY = 100;
            const scaleX = 200;
            const scaleY = 40;
            
            ctx.beginPath();
            let first = true;
            
            for (let t = -1; t <= 1; t += 0.001) {
                let y = 0;
                
                switch(signalType) {
                    case 'music':
                        // æ¨¡æ‹ŸéŸ³ä¹ä¿¡å·ï¼ˆå¤šé¢‘ç‡åˆ†é‡ï¼‰
                        y = 0.5 * Math.sin(2 * Math.PI * 440 * t) + 
                            0.3 * Math.sin(2 * Math.PI * 880 * t) + 
                            0.2 * Math.sin(2 * Math.PI * 1320 * t);
                        break;
                    case 'speech':
                        // æ¨¡æ‹Ÿè¯­éŸ³ä¿¡å·
                        y = Math.sin(2 * Math.PI * 300 * t) * (1 + 0.5 * Math.sin(2 * Math.PI * 50 * t));
                        break;
                    case 'noisy':
                        // å«å™ªå£°ä¿¡å·
                        y = Math.sin(2 * Math.PI * 100 * t) + 0.3 * (Math.random() - 0.5);
                        break;
                }
                
                const x = centerX + t * scaleX;
                const plotY = centerY - y * scaleY;
                
                if (first) {
                    ctx.moveTo(x, plotY);
                    first = false;
                } else {
                    ctx.lineTo(x, plotY);
                }
            }
            ctx.stroke();
        }
        
        function drawFilteredSignal(ctx, signalType, filterType) {
            if (filterType === 'none') {
                drawRealSignal(ctx, signalType);
                return;
            }
            
            ctx.strokeStyle = colors.secondary;
            ctx.lineWidth = 2;
            
            // ç®€åŒ–çš„æ»¤æ³¢æ•ˆæœæ¼”ç¤º
            const centerX = 250;
            const centerY = 100;
            const scaleX = 200;
            const scaleY = 40;
            
            ctx.beginPath();
            let first = true;
            
            for (let t = -1; t <= 1; t += 0.001) {
                let y = 0;
                
                switch(signalType) {
                    case 'music':
                        // æ»¤æ³¢ååªä¿ç•™ä½é¢‘åˆ†é‡
                        y = 0.5 * Math.sin(2 * Math.PI * 440 * t) + 
                            0.3 * Math.sin(2 * Math.PI * 880 * t);
                        if (filterType === 'butterworth') {
                            y *= 0.8; // æ¨¡æ‹Ÿæ»¤æ³¢æŸå¤±
                        }
                        break;
                    case 'speech':
                        y = Math.sin(2 * Math.PI * 300 * t) * (1 + 0.5 * Math.sin(2 * Math.PI * 50 * t));
                        break;
                    case 'noisy':
                        // æ»¤æ³¢å»é™¤éƒ¨åˆ†å™ªå£°
                        y = Math.sin(2 * Math.PI * 100 * t);
                        if (filterType === 'butterworth') {
                            y += 0.1 * (Math.random() - 0.5);
                        }
                        break;
                }
                
                const x = centerX + t * scaleX;
                const plotY = centerY - y * scaleY;
                
                if (first) {
                    ctx.moveTo(x, plotY);
                    first = false;
                } else {
                    ctx.lineTo(x, plotY);
                }
            }
            ctx.stroke();
        }
        
        function drawSampledSignal(ctx, signalType, filterType, samplingRate) {
            const centerX = 250;
            const centerY = 100;
            const scaleX = 200;
            const scaleY = 40;
            const Ts = 1 / samplingRate;
            
            // ç»˜åˆ¶æŠ½æ ·ç‚¹
            ctx.fillStyle = colors.danger;
            ctx.strokeStyle = colors.danger;
            ctx.lineWidth = 1;
            
            for (let n = Math.floor(-samplingRate); n <= samplingRate; n++) {
                const t = n * Ts;
                if (Math.abs(t) <= 1) {
                    let y = 0;
                    
                    // æ ¹æ®ä¿¡å·ç±»å‹å’Œæ»¤æ³¢ç±»å‹è®¡ç®—æŠ½æ ·å€¼
                    switch(signalType) {
                        case 'music':
                            y = 0.5 * Math.sin(2 * Math.PI * 440 * t) + 
                                0.3 * Math.sin(2 * Math.PI * 880 * t);
                            if (filterType === 'none') {
                                y += 0.2 * Math.sin(2 * Math.PI * 1320 * t);
                            }
                            break;
                        case 'speech':
                            y = Math.sin(2 * Math.PI * 300 * t) * (1 + 0.5 * Math.sin(2 * Math.PI * 50 * t));
                            break;
                        case 'noisy':
                            y = Math.sin(2 * Math.PI * 100 * t);
                            if (filterType === 'none') {
                                y += 0.3 * (Math.random() - 0.5);
                            }
                            break;
                    }
                    
                    const x = centerX + t * scaleX;
                    const plotY = centerY - y * scaleY;
                    
                    // æŠ½æ ·ç‚¹
                    ctx.beginPath();
                    ctx.arc(x, plotY, 2, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // å‚ç›´çº¿
                    ctx.beginPath();
                    ctx.moveTo(x, centerY);
                    ctx.lineTo(x, plotY);
                    ctx.stroke();
                }
            }
        }
        
        function analyzeRealSampling(signalType, filterType, samplingRate) {
            const analysis = document.getElementById('realSamplingAnalysis');
            
            let result = `<strong>å®é™…æŠ½æ ·ç³»ç»Ÿåˆ†æ:</strong><br>`;
            result += `ä¿¡å·ç±»å‹: ${signalType}<br>`;
            result += `æŠ—æ··å æ»¤æ³¢: ${filterType}<br>`;
            result += `æŠ½æ ·ç‡: ${samplingRate} Hz<br><br>`;
            
            let maxFreq = 0;
            switch(signalType) {
                case 'music':
                    maxFreq = 1320;
                    result += `æœ€é«˜é¢‘ç‡åˆ†é‡: 1320 Hz<br>`;
                    break;
                case 'speech':
                    maxFreq = 300;
                    result += `æœ€é«˜é¢‘ç‡åˆ†é‡: ~300 Hz<br>`;
                    break;
                case 'noisy':
                    maxFreq = 100;
                    result += `ä¿¡å·é¢‘ç‡: 100 Hz<br>`;
                    break;
            }
            
            if (samplingRate >= 2 * maxFreq) {
                result += `âœ… æŠ½æ ·ç‡å……è¶³`;
            } else {
                result += `âŒ å¯èƒ½å‘ç”Ÿæ··å `;
            }
            
            if (filterType !== 'none') {
                result += `<br>âœ… ä½¿ç”¨æŠ—æ··å æ»¤æ³¢å™¨`;
            }
            
            analysis.innerHTML = result;
        }
        
        // ADCæ¼”ç¤º
        function updateADCDemo() {
            const bits = parseInt(document.getElementById('adcBits').value);
            const samplingRate = parseInt(document.getElementById('adcSamplingRate').value);
            
            document.getElementById('adcSamplingRateValue').textContent = samplingRate;
            
            const originalCanvas = document.getElementById('adcOriginalCanvas');
            const quantizedCanvas = document.getElementById('adcQuantizedCanvas');
            const originalCtx = originalCanvas.getContext('2d');
            const quantizedCtx = quantizedCanvas.getContext('2d');
            
            // ç»˜åˆ¶åŸå§‹ä¿¡å·
            drawAxis(originalCtx, 600, 250, 't', 'åŸå§‹ä¿¡å·');
            drawADCOriginal(originalCtx);
            
            // ç»˜åˆ¶é‡åŒ–åä¿¡å·
            drawAxis(quantizedCtx, 600, 250, 't', 'é‡åŒ–ä¿¡å·');
            drawADCQuantized(quantizedCtx, bits, samplingRate);
            
            analyzeADCPerformance(bits, samplingRate);
        }
        
        function drawADCOriginal(ctx) {
            ctx.strokeStyle = colors.info;
            ctx.lineWidth = 2;
            
            const centerX = 300;
            const centerY = 125;
            const scaleX = 80;
            const scaleY = 60;
            
            ctx.beginPath();
            let first = true;
            
            for (let t = -3; t <= 3; t += 0.01) {
                const y = Math.sin(2 * Math.PI * 0.5 * t) + 0.3 * Math.sin(2 * Math.PI * 2 * t);
                const x = centerX + t * scaleX;
                const plotY = centerY - y * scaleY;
                
                if (first) {
                    ctx.moveTo(x, plotY);
                    first = false;
                } else {
                    ctx.lineTo(x, plotY);
                }
            }
            ctx.stroke();
        }
        
        function drawADCQuantized(ctx, bits, samplingRate) {
            const centerX = 300;
            const centerY = 125;
            const scaleX = 80;
            const scaleY = 60;
            const Ts = 1 / samplingRate;
            const levels = Math.pow(2, bits);
            const stepSize = 2 / levels;
            
            // ç»˜åˆ¶é‡åŒ–çº§åˆ«çº¿
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            for (let level = -levels/2; level <= levels/2; level++) {
                const y = level * stepSize;
                const plotY = centerY - y * scaleY;
                ctx.beginPath();
                ctx.moveTo(50, plotY);
                ctx.lineTo(550, plotY);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶é‡åŒ–åçš„ä¿¡å·
            ctx.strokeStyle = colors.danger;
            ctx.lineWidth = 2;
            ctx.fillStyle = colors.danger;
            
            let prevX = null, prevY = null;
            
            for (let n = Math.floor(-3 * samplingRate); n <= 3 * samplingRate; n++) {
                const t = n * Ts;
                if (Math.abs(t) <= 3) {
                    const originalY = Math.sin(2 * Math.PI * 0.5 * t) + 0.3 * Math.sin(2 * Math.PI * 2 * t);
                    
                    // é‡åŒ–
                    const quantizedLevel = Math.round(originalY / stepSize);
                    const quantizedY = quantizedLevel * stepSize;
                    
                    const x = centerX + t * scaleX;
                    const plotY = centerY - quantizedY * scaleY;
                    
                    // æŠ½æ ·ç‚¹
                    ctx.beginPath();
                    ctx.arc(x, plotY, 2, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // è¿æ¥çº¿ï¼ˆé˜¶æ¢¯çŠ¶ï¼‰
                    if (prevX !== null) {
                        ctx.beginPath();
                        ctx.moveTo(prevX, prevY);
                        ctx.lineTo(x, prevY);
                        ctx.lineTo(x, plotY);
                        ctx.stroke();
                    }
                    
                    prevX = x;
                    prevY = plotY;
                }
            }
        }
        
        function analyzeADCPerformance(bits, samplingRate) {
            const analysis = document.getElementById('adcAnalysis');
            const levels = Math.pow(2, bits);
            const snr = 6.02 * bits + 1.76; // ç†è®ºSNR
            
            let result = `<strong>ADCæ€§èƒ½åˆ†æ:</strong><br>`;
            result += `åˆ†è¾¨ç‡: ${bits} ä½<br>`;
            result += `é‡åŒ–çº§åˆ«: ${levels}<br>`;
            result += `æŠ½æ ·ç‡: ${samplingRate} Hz<br>`;
            result += `ç†è®ºSNR: ${snr.toFixed(1)} dB<br>`;
            result += `åŠ¨æ€èŒƒå›´: ${(bits * 6.02).toFixed(1)} dB`;
            
            analysis.innerHTML = result;
        }
        
        // åŠ¨ç”»æ¼”ç¤º
        function animateSampling() {
            let fs = 1;
            const maxFs = 50;
            const fm = parseFloat(document.getElementById('signalFreq').value);
            
            const animate = () => {
                document.getElementById('samplingFreq').value = fs;
                updateSamplingDemo();
                fs += 2;
                
                if (fs <= maxFs) {
                    animationId = setTimeout(animate, 500);
                }
            };
            
            animate();
        }
        
        // ç»ƒä¹ é¢˜ç­”æ¡ˆæ£€æŸ¥
        function checkAnswer1() {
            const answer = parseFloat(document.getElementById('answer1').value);
            const feedback = document.getElementById('feedback1');
            
            if (Math.abs(answer - 10) < 0.1) {
                feedback.textContent = 'æ­£ç¡®ï¼æ ¹æ®æŠ½æ ·å®šç†ï¼Œfs â‰¥ 2fm = 2Ã—5 = 10Hzã€‚';
                feedback.className = 'feedback correct';
            } else {
                feedback.textContent = 'é”™è¯¯ã€‚æŠ½æ ·å®šç†è¦æ±‚fs â‰¥ 2fmï¼Œæ‰€ä»¥è‡³å°‘éœ€è¦10Hzçš„æŠ½æ ·é¢‘ç‡ã€‚';
                feedback.className = 'feedback incorrect';
            }
            feedback.style.display = 'block';
        }
        
        function checkAnswer2() {
            const answer = document.getElementById('answer2').value;
            const feedback = document.getElementById('feedback2');
            
            if (answer === 'aliasing_5hz') {
                feedback.textContent = 'æ­£ç¡®ï¼5Hzåˆ†é‡ä¼šæ··å åˆ°8-5=3Hzï¼Œå› ä¸ºfs/2=4Hzï¼Œè€Œ5Hz>4Hzã€‚';
                feedback.className = 'feedback correct';
            } else {
                feedback.textContent = 'é”™è¯¯ã€‚æŠ½æ ·ç‡8Hzçš„å¥ˆå¥æ–¯ç‰¹é¢‘ç‡æ˜¯4Hzï¼Œ5Hzåˆ†é‡ä¼šæ··å åˆ°3Hzã€‚';
                feedback.className = 'feedback incorrect';
            }
            feedback.style.display = 'block';
        }
        
        function checkAnswer3() {
            const answer = document.getElementById('answer3').value;
            const feedback = document.getElementById('feedback3');
            
            if (answer === 'sinc') {
                feedback.textContent = 'æ­£ç¡®ï¼ç†æƒ³é‡æ„ä½¿ç”¨sincå‡½æ•°ï¼šx(t) = Î£x(nTs)sinc((t-nTs)/Ts)ã€‚';
                feedback.className = 'feedback correct';
            } else {
                feedback.textContent = 'é”™è¯¯ã€‚ç†æƒ³é‡æ„ä½¿ç”¨sincå‡½æ•°è¿›è¡Œæ’å€¼ï¼Œè¿™æ˜¯æŠ½æ ·å®šç†çš„ç›´æ¥ç»“æœã€‚';
                feedback.className = 'feedback incorrect';
            }
            feedback.style.display = 'block';
        }
        
        function checkAnswer4() {
            const answer = document.getElementById('answer4').value;
            const feedback = document.getElementById('feedback4');
            
            if (answer === 'human_hearing') {
                feedback.textContent = 'æ­£ç¡®ï¼äººè€³å¬è§‰èŒƒå›´çº¦20kHzï¼Œ44.1kHz = 2.205Ã—20kHzï¼Œæ»¡è¶³æŠ½æ ·å®šç†ã€‚';
                feedback.className = 'feedback correct';
            } else {
                feedback.textContent = 'é”™è¯¯ã€‚44.1kHzçš„é€‰æ‹©ä¸»è¦æ˜¯ä¸ºäº†è¦†ç›–äººè€³20kHzçš„å¬è§‰èŒƒå›´ï¼Œæ»¡è¶³æŠ½æ ·å®šç†ã€‚';
                feedback.className = 'feedback incorrect';
            }
            feedback.style.display = 'block';
        }
        
        function checkAnswer5() {
            const answer = parseFloat(document.getElementById('answer5').value);
            const feedback = document.getElementById('feedback5');
            
            // ä¸ºäº†1%çš„è¯¯å·®ï¼Œé€šå¸¸éœ€è¦10-20%çš„ä½™é‡ï¼Œæ‰€ä»¥çº¦8.8-9.6kHz
            if (answer >= 8.5 && answer <= 10) {
                feedback.textContent = 'æ­£ç¡®ï¼è€ƒè™‘åˆ°é‡æ„è¯¯å·®å’Œå®é™…æ»¤æ³¢å™¨ç‰¹æ€§ï¼Œé€šå¸¸é€‰æ‹©8.8-9.6kHzå·¦å³ã€‚';
                feedback.className = 'feedback correct';
            } else {
                feedback.textContent = 'é”™è¯¯ã€‚ç†è®ºæœ€ä½8kHzï¼Œä½†å®é™…éœ€è¦è€ƒè™‘æŠ—æ··å æ»¤æ³¢å™¨å’Œé‡æ„è¯¯å·®ï¼Œçº¦éœ€8.8-9.6kHzã€‚';
                feedback.className = 'feedback incorrect';
            }
            feedback.style.display = 'block';
        }
        
        // åˆå§‹åŒ–
        window.onload = function() {
            updateSamplingDemo();
            updateTheoremDemo();
            updateReconstructionDemo();
            updateRealSamplingDemo();
            updateADCDemo();
        };
        
        // äº‹ä»¶ç›‘å¬å™¨
        document.getElementById('signalFreq').addEventListener('input', updateSamplingDemo);
        document.getElementById('samplingFreq').addEventListener('input', updateSamplingDemo);
        document.getElementById('signalBandwidth').addEventListener('input', updateTheoremDemo);
        document.getElementById('samplingRatio').addEventListener('input', updateTheoremDemo);
        document.getElementById('sampleCount').addEventListener('input', updateReconstructionDemo);
        document.getElementById('sincLength').addEventListener('input', updateReconstructionDemo);
        document.getElementById('realSamplingRate').addEventListener('input', updateRealSamplingDemo);
        document.getElementById('adcSamplingRate').addEventListener('input', updateADCDemo);
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>非周期信号的频谱分析</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
            padding: 30px;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        h2 {
            color: #34495e;
            border-left: 4px solid #667eea;
            padding-left: 15px;
            margin-top: 40px;
        }
        
        h3 {
            color: #764ba2;
            margin-top: 25px;
        }
        
        .section {
            margin-bottom: 40px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .formula {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Times New Roman', serif;
            font-size: 1.1em;
            margin: 15px 0;
            border-left: 4px solid #667eea;
            text-align: center;
        }
        
        .formula-pair {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .forward-transform {
            background: #e8f5e8;
            border-left: 4px solid #27ae60;
        }
        
        .inverse-transform {
            background: #fef9e7;
            border-left: 4px solid #f39c12;
        }
        
        .canvas-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
        }
        
        .signal-canvas {
            border: 2px solid #bdc3c7;
            border-radius: 8px;
            background: white;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        
        .controls {
            background: #f0f3ff;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid #667eea;
        }
        
        .controls label {
            margin-right: 15px;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .controls input, .controls select {
            margin: 5px;
            padding: 5px 10px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
        }
        
        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 5px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .exercise {
            background: #fff8e1;
            border: 1px solid #ffcc02;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .exercise h4 {
            color: #f57f17;
            margin-top: 0;
        }
        
        .answer-input {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 4px;
            margin: 10px;
            width: 200px;
        }
        
        .feedback {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .correct {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .incorrect {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .key-points {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .key-points h4 {
            color: #0d47a1;
            margin-top: 0;
        }
        
        .transform-demo {
            background: #f3e5f5;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px solid #9c27b0;
        }
        
        .properties-demo {
            background: #e8f5e8;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px solid #4caf50;
        }
        
        .typical-signals {
            background: #fff3e0;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px solid #ff9800;
        }
        
        .periodic-ft {
            background: #fce4ec;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px solid #e91e63;
        }
        
        .spectrum-display {
            font-family: monospace;
            background: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #ddd;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .dual-view {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            align-items: start;
        }
        
        ul li {
            margin: 8px 0;
        }
        
        .math-expression {
            font-size: 0.9em;
            color: #666;
            font-style: italic;
        }
        
        .highlight {
            background: #ffeb3b;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .property-card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .property-card h5 {
            margin-top: 0;
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🌈 非周期信号的频谱分析</h1>
        
        <div class="section">
            <h2>1. 傅里叶变换的定义</h2>
            
            <h3>1.1 从傅里叶级数到傅里叶变换</h3>
            <div class="key-points">
                <h4>变换的产生：</h4>
                <ul>
                    <li>周期信号 → 离散频谱（傅里叶级数）</li>
                    <li>非周期信号 → 连续频谱（傅里叶变换）</li>
                    <li>当周期T→∞时，基频Ω→0，离散谱线变为连续频谱</li>
                </ul>
            </div>
            
            <h3>1.2 傅里叶变换对</h3>
            <div class="formula-pair">
                <div class="formula forward-transform">
                    <strong>正变换（时域→频域）</strong><br>
                    X(jω) = ∫_{-∞}^{∞} x(t)e^{-jωt}dt
                </div>
                <div class="formula inverse-transform">
                    <strong>逆变换（频域→时域）</strong><br>
                    x(t) = (1/2π)∫_{-∞}^{∞} X(jω)e^{jωt}dω
                </div>
            </div>
            
            <div class="formula">
                记号：x(t) ↔ X(jω) 或 x(t) ⟷ X(jω)
            </div>
            
            <div class="transform-demo">
                <h4>傅里叶变换可视化</h4>
                <div class="controls">
                    <label>选择信号:</label>
                    <select id="ftSignal" onchange="updateFourierTransform()">
                        <option value="rect">矩形脉冲</option>
                        <option value="exp">单边指数</option>
                        <option value="gaussian">高斯脉冲</option>
                        <option value="triangle">三角脉冲</option>
                    </select>
                    <label>参数调节:</label>
                    <input type="range" id="ftParam" min="0.5" max="5" step="0.1" value="2">
                    <span id="ftParamValue">2</span>
                    <button onclick="updateFourierTransform()">更新变换</button>
                </div>
                <div class="canvas-container">
                    <canvas id="ftTimeCanvas" class="signal-canvas" width="600" height="300"></canvas>
                    <canvas id="ftFreqCanvas" class="signal-canvas" width="600" height="300"></canvas>
                </div>
                <div id="ftFormula" class="spectrum-display">变换公式将在这里显示</div>
            </div>
            
            <div class="exercise">
                <h4>🔧 练习题1：</h4>
                <p>矩形脉冲信号的傅里叶变换是什么函数？</p>
                <select id="answer1" class="answer-input">
                    <option value="">选择答案</option>
                    <option value="sinc">sinc函数</option>
                    <option value="exp">指数函数</option>
                    <option value="gaussian">高斯函数</option>
                </select>
                <button onclick="checkAnswer1()">提交答案</button>
                <div id="feedback1" class="feedback" style="display:none;"></div>
            </div>
        </div>
        
        <div class="section">
            <h2>2. 典型非周期信号的频谱</h2>
            
            <div class="typical-signals">
                <h4>常见信号的傅里叶变换对</h4>
                
                <h5>2.1 矩形脉冲</h5>
                <div class="formula">
                    x(t) = {A, |t| ≤ T/2; 0, |t| > T/2}<br>
                    X(jω) = AT·sinc(ωT/2) = AT·sin(ωT/2)/(ωT/2)
                </div>
                
                <h5>2.2 单边指数信号</h5>
                <div class="formula">
                    x(t) = e^{-at}u(t), a > 0<br>
                    X(jω) = 1/(a + jω)
                </div>
                
                <h5>2.3 双边指数信号</h5>
                <div class="formula">
                    x(t) = e^{-a|t|}, a > 0<br>
                    X(jω) = 2a/(a² + ω²)
                </div>
                
                <h5>2.4 高斯脉冲</h5>
                <div class="formula">
                    x(t) = e^{-at²}, a > 0<br>
                    X(jω) = √(π/a)·e^{-ω²/(4a)}
                </div>
                
                <h5>2.5 冲激函数</h5>
                <div class="formula">
                    δ(t) ↔ 1<br>
                    δ(t - t₀) ↔ e^{-jωt₀}
                </div>
                
                <div class="controls">
                    <label>对比显示:</label>
                    <select id="compareSignals" onchange="updateSignalComparison()">
                        <option value="all">全部信号</option>
                        <option value="pulse">脉冲类</option>
                        <option value="exponential">指数类</option>
                    </select>
                    <label>显示类型:</label>
                    <select id="spectrumView" onchange="updateSignalComparison()">
                        <option value="magnitude">幅度谱</option>
                        <option value="phase">相位谱</option>
                        <option value="both">幅度+相位</option>
                    </select>
                </div>
                <div class="canvas-container">
                    <canvas id="typicalTimeCanvas" class="signal-canvas" width="700" height="350"></canvas>
                    <canvas id="typicalFreqCanvas" class="signal-canvas" width="700" height="350"></canvas>
                </div>
            </div>
            
            <div class="key-points">
                <h4>频谱特点总结：</h4>
                <ul>
                    <li><strong>时域越窄，频域越宽</strong>（不确定性原理）</li>
                    <li><strong>对称性</strong>：实偶函数 ↔ 实偶函数</li>
                    <li><strong>平滑性</strong>：时域越平滑，频域衰减越快</li>
                    <li><strong>能量守恒</strong>：∫|x(t)|²dt = (1/2π)∫|X(jω)|²dω</li>
                </ul>
            </div>
            
            <div class="exercise">
                <h4>🔧 练习题2：</h4>
                <p>如果矩形脉冲的宽度减半，其频谱的主瓣宽度会如何变化？</p>
                <select id="answer2" class="answer-input">
                    <option value="">选择答案</option>
                    <option value="double">增加一倍</option>
                    <option value="half">减少一半</option>
                    <option value="same">保持不变</option>
                </select>
                <button onclick="checkAnswer2()">提交答案</button>
                <div id="feedback2" class="feedback" style="display:none;"></div>
            </div>
        </div>
        
        <div class="section">
            <h2>3. 傅里叶变换的性质</h2>
            
            <div class="properties-demo">
                <h4>重要性质及其应用</h4>
                
                <div class="property-card">
                    <h5>3.1 线性性质</h5>
                    <div class="formula">
                        ax₁(t) + bx₂(t) ↔ aX₁(jω) + bX₂(jω)
                    </div>
                </div>
                
                <div class="property-card">
                    <h5>3.2 时移性质</h5>
                    <div class="formula">
                        x(t - t₀) ↔ X(jω)e^{-jωt₀}
                    </div>
                    <p>时移只影响相位谱，不影响幅度谱</p>
                </div>
                
                <div class="property-card">
                    <h5>3.3 频移性质</h5>
                    <div class="formula">
                        x(t)e^{jω₀t} ↔ X(j(ω - ω₀))
                    </div>
                    <p>调制的数学基础</p>
                </div>
                
                <div class="property-card">
                    <h5>3.4 尺度变换性质</h5>
                    <div class="formula">
                        x(at) ↔ (1/|a|)X(jω/a)
                    </div>
                    <p>时域压缩a倍，频域扩展a倍且幅度缩小1/|a|</p>
                </div>
                
                <div class="property-card">
                    <h5>3.5 对偶性质</h5>
                    <div class="formula">
                        X(jt) ↔ 2πx(-ω)
                    </div>
                    <p>时频域的对称关系</p>
                </div>
                
                <div class="property-card">
                    <h5>3.6 卷积定理</h5>
                    <div class="formula">
                        x₁(t) * x₂(t) ↔ X₁(jω)X₂(jω)<br>
                        x₁(t)x₂(t) ↔ (1/2π)X₁(jω) * X₂(jω)
                    </div>
                    <p>系统分析的重要工具</p>
                </div>
                
                <div class="controls">
                    <label>选择性质演示:</label>
                    <select id="propertyDemo" onchange="updatePropertyDemo()">
                        <option value="timeshift">时移性质</option>
                        <option value="freqshift">频移性质</option>
                        <option value="scaling">尺度变换</option>
                        <option value="convolution">卷积定理</option>
                    </select>
                    <label>参数:</label>
                    <input type="range" id="propertyParam" min="-3" max="3" step="0.1" value="1">
                    <span id="propertyParamValue">1</span>
                    <button onclick="updatePropertyDemo()">更新演示</button>
                </div>
                <div class="dual-view">
                    <div>
                        <canvas id="propertyOriginalCanvas" class="signal-canvas" width="500" height="300"></canvas>
                        <p style="text-align: center;">原信号</p>
                    </div>
                    <div>
                        <canvas id="propertyTransformedCanvas" class="signal-canvas" width="500" height="300"></canvas>
                        <p style="text-align: center;">变换后信号</p>
                    </div>
                </div>
                <div id="propertyExplanation" class="spectrum-display">性质说明将在这里显示</div>
            </div>
            
            <div class="exercise">
                <h4>🔧 练习题3：</h4>
                <p>如果x(t) ↔ X(jω)，那么x(2t)的傅里叶变换是：</p>
                <select id="answer3" class="answer-input">
                    <option value="">选择答案</option>
                    <option value="half_X_half_w">(1/2)X(jω/2)</option>
                    <option value="X_2w">X(j2ω)</option>
                    <option value="2X_w">2X(jω)</option>
                </select>
                <button onclick="checkAnswer3()">提交答案</button>
                <div id="feedback3" class="feedback" style="display:none;"></div>
            </div>
        </div>
        
        <div class="section">
            <h2>4. 周期信号的傅里叶变换</h2>
            
            <div class="periodic-ft">
                <h4>周期信号的频域表示</h4>
                
                <h5>4.1 基本思想</h5>
                <div class="key-points">
                    <ul>
                        <li>周期信号的傅里叶变换包含冲激函数</li>
                        <li>频谱是离散的，用冲激函数表示</li>
                        <li>连接了傅里叶级数和傅里叶变换</li>
                    </ul>
                </div>
                
                <h5>4.2 一般公式</h5>
                <div class="formula">
                    若 x(t) = Σ Cₙe^{jnΩt} （傅里叶级数）<br>
                    则 X(jω) = 2π Σ Cₙδ(ω - nΩ)
                </div>
                
                <h5>4.3 典型周期信号</h5>
                
                <div class="formula">
                    <strong>冲激串：</strong><br>
                    ∑δ(t - nT) ↔ (2π/T)∑δ(ω - nΩ)
                </div>
                
                <div class="formula">
                    <strong>周期方波：</strong><br>
                    X(jω) = 2π∑[(2A sin(nΩτ/2))/(nΩτ/2)]δ(ω - nΩ)
                </div>
                
                <div class="controls">
                    <label>周期信号:</label>
                    <select id="periodicSignal" onchange="updatePeriodicFT()">
                        <option value="impulse_train">冲激串</option>
                        <option value="square_wave">周期方波</option>
                        <option value="sawtooth_wave">周期锯齿波</option>
                    </select>
                    <label>周期T:</label>
                    <input type="range" id="periodValue" min="1" max="5" step="0.5" value="2">
                    <span id="periodValueLabel">2</span>
                    <label>占空比:</label>
                    <input type="range" id="dutyRatio" min="0.1" max="0.9" step="0.1" value="0.5">
                    <span id="dutyRatioLabel">0.5</span>
                    <button onclick="updatePeriodicFT()">更新变换</button>
                </div>
                
                <div class="canvas-container">
                    <canvas id="periodicTimeCanvas" class="signal-canvas" width="600" height="250"></canvas>
                    <canvas id="periodicFreqCanvas" class="signal-canvas" width="600" height="250"></canvas>
                    <canvas id="periodicSpectrumCanvas" class="signal-canvas" width="600" height="250"></canvas>
                </div>
                <div id="periodicAnalysis" class="spectrum-display">周期信号分析结果</div>
            </div>
            
            <div class="key-points">
                <h4>重要结论：</h4>
                <ul>
                    <li><strong>时域周期 → 频域离散</strong></li>
                    <li><strong>时域离散 → 频域周期</strong></li>
                    <li>周期信号的功率有限，但能量无限</li>
                    <li>冲激函数是连接连续和离散频谱的桥梁</li>
                </ul>
            </div>
            
            <div class="exercise">
                <h4>🔧 练习题4：</h4>
                <p>周期为T的冲激串，其频域表示中相邻冲激的间隔是：</p>
                <input type="text" id="answer4" class="answer-input" placeholder="输入答案（如2π/T）">
                <button onclick="checkAnswer4()">提交答案</button>
                <div id="feedback4" class="feedback" style="display:none;"></div>
            </div>
        </div>
        
        <div class="section">
            <h2>5. 傅里叶变换的应用</h2>
            
            <div class="transform-demo">
                <h4>综合应用示例</h4>
                
                <h5>5.1 滤波器设计</h5>
                <div class="key-points">
                    <ul>
                        <li>理想低通滤波器：H(jω) = {1, |ω| ≤ ωc; 0, |ω| > ωc}</li>
                        <li>冲激响应：h(t) = (ωc/π)sinc(ωct/π)</li>
                        <li>实际滤波器需要考虑因果性和稳定性</li>
                    </ul>
                </div>
                
                <h5>5.2 调制与解调</h5>
                <div class="formula">
                    调制：x(t)cos(ω₀t) ↔ [X(j(ω-ω₀)) + X(j(ω+ω₀))]/2<br>
                    频谱搬移到载波频率附近
                </div>
                
                <div class="controls">
                    <label>应用演示:</label>
                    <select id="applicationDemo" onchange="updateApplicationDemo()">
                        <option value="filtering">低通滤波</option>
                        <option value="modulation">AM调制</option>
                        <option value="sampling">采样定理</option>
                    </select>
                    <label>参数:</label>
                    <input type="range" id="appParam" min="0.5" max="5" step="0.1" value="2">
                    <span id="appParamValue">2</span>
                    <button onclick="updateApplicationDemo()">更新演示</button>
                </div>
                
                <div class="canvas-container">
                    <canvas id="appInputCanvas" class="signal-canvas" width="500" height="200"></canvas>
                    <canvas id="appOutputCanvas" class="signal-canvas" width="500" height="200"></canvas>
                    <canvas id="appSpectrumCanvas" class="signal-canvas" width="500" height="200"></canvas>
                </div>
                <div id="applicationAnalysis" class="spectrum-display">应用分析结果</div>
            </div>
        </div>
        
        <div class="section">
            <h2>📝 本章小结</h2>
            <div class="key-points">
                <h4>核心要点：</h4>
                <ul>
                    <li><strong>傅里叶变换</strong>：非周期信号的频域分析工具，连接时域和频域</li>
                    <li><strong>典型信号变换</strong>：掌握矩形、指数、高斯等信号的变换对</li>
                    <li><strong>重要性质</strong>：线性、时移、频移、尺度变换、卷积定理等</li>
                    <li><strong>周期信号变换</strong>：用冲激函数表示离散频谱</li>
                    <li><strong>工程应用</strong>：滤波、调制、采样等系统分析基础</li>
                </ul>
            </div>
            
            <div class="exercise">
                <h4>🎯 综合练习：</h4>
                <p>计算信号x(t) = e^(-2|t|)的傅里叶变换X(jω)在ω=1处的值：</p>
                <input type="number" id="answer5" class="answer-input" placeholder="输入数值" step="0.01">
                <button onclick="checkAnswer5()">提交答案</button>
                <div id="feedback5" class="feedback" style="display:none;"></div>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let animationId;
        const colors = {
            primary: '#667eea',
            secondary: '#764ba2',
            accent: '#f093fb',
            success: '#27ae60',
            warning: '#f39c12',
            danger: '#e74c3c',
            info: '#3498db'
        };
        
        // 数学工具函数
        function sinc(x) {
            return (Math.abs(x) < 1e-10) ? 1 : Math.sin(x) / x;
        }
        
        function rect(t, T) {
            return (Math.abs(t) <= T/2) ? 1 : 0;
        }
        
        function triangle(t, T) {
            return (Math.abs(t) <= T) ? (1 - Math.abs(t)/T) : 0;
        }
        
        // 绘图工具函数
        function drawAxis(ctx, width, height, xLabel = 't', yLabel = 'x(t)', showGrid = true) {
            ctx.clearRect(0, 0, width, height);
            
            if (showGrid) {
                ctx.strokeStyle = '#f0f0f0';
                ctx.lineWidth = 0.5;
                for (let i = 40; i < width - 40; i += 20) {
                    ctx.beginPath();
                    ctx.moveTo(i, 20);
                    ctx.lineTo(i, height - 20);
                    ctx.stroke();
                }
                for (let i = 20; i < height - 20; i += 20) {
                    ctx.beginPath();
                    ctx.moveTo(40, i);
                    ctx.lineTo(width - 40, i);
                    ctx.stroke();
                }
            }
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            const centerX = width / 2;
            const centerY = height / 2;
            
            // X轴
            ctx.beginPath();
            ctx.moveTo(40, centerY);
            ctx.lineTo(width - 40, centerY);
            ctx.stroke();
            
            // Y轴
            ctx.beginPath();
            ctx.moveTo(centerX, 20);
            ctx.lineTo(centerX, height - 20);
            ctx.stroke();
            
            // 箭头
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.moveTo(width - 40, centerY);
            ctx.lineTo(width - 48, centerY - 4);
            ctx.lineTo(width - 48, centerY + 4);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 20);
            ctx.lineTo(centerX - 4, 28);
            ctx.lineTo(centerX + 4, 28);
            ctx.fill();
            
            // 标签
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText(xLabel, width - 30, centerY + 20);
            ctx.fillText(yLabel, centerX + 10, 35);
            ctx.fillText('0', centerX + 5, centerY + 15);
        }
        
        function drawFrequencyAxis(ctx, width, height, symmetric = true) {
            ctx.clearRect(0, 0, width, height);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            const centerX = symmetric ? width / 2 : 60;
            const centerY = height - 40;
            
            // X轴（频率轴）
            ctx.beginPath();
            ctx.moveTo(40, centerY);
            ctx.lineTo(width - 40, centerY);
            ctx.stroke();
            
            // Y轴（幅度轴）
            ctx.beginPath();
            ctx.moveTo(centerX, 20);
            ctx.lineTo(centerX, centerY);
            ctx.stroke();
            
            // 标签
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText('ω', width - 30, centerY + 20);
            ctx.fillText('|X(jω)|', centerX + 10, 35);
            ctx.fillText('0', centerX - 10, centerY + 15);
        }
        
        // 傅里叶变换演示
        function updateFourierTransform() {
            const signal = document.getElementById('ftSignal').value;
            const param = parseFloat(document.getElementById('ftParam').value);
            document.getElementById('ftParamValue').textContent = param;
            
            const timeCanvas = document.getElementById('ftTimeCanvas');
            const freqCanvas = document.getElementById('ftFreqCanvas');
            const timeCtx = timeCanvas.getContext('2d');
            const freqCtx = freqCanvas.getContext('2d');
            
            // 绘制时域信号
            drawAxis(timeCtx, 600, 300, 't', 'x(t)');
            drawTimeSignal(timeCtx, signal, param);
            
            // 绘制频域信号
            drawFrequencyAxis(freqCtx, 600, 300, true);
            drawFrequencySpectrum(freqCtx, signal, param);
            
            // 显示变换公式
            displayTransformFormula(signal, param);
        }
        
        function drawTimeSignal(ctx, signalType, param) {
            ctx.strokeStyle = colors.primary;
            ctx.lineWidth = 3;
            
            const centerX = 300;
            const centerY = 150;
            const scaleX = 50;
            const scaleY = 80;
            
            ctx.beginPath();
            let first = true;
            
            for (let t = -6; t <= 6; t += 0.02) {
                let y = 0;
                
                switch(signalType) {
                    case 'rect':
                        y = rect(t, param);
                        break;
                    case 'exp':
                        y = (t >= 0) ? Math.exp(-param * t) : 0;
                        break;
                    case 'gaussian':
                        y = Math.exp(-param * t * t);
                        break;
                    case 'triangle':
                        y = triangle(t, param);
                        break;
                }
                
                const x = centerX + t * scaleX;
                const plotY = centerY - y * scaleY;
                
                if (first) {
                    ctx.moveTo(x, plotY);
                    first = false;
                } else {
                    ctx.lineTo(x, plotY);
                }
            }
            ctx.stroke();
        }
        
        function drawFrequencySpectrum(ctx, signalType, param) {
            ctx.strokeStyle = colors.secondary;
            ctx.lineWidth = 3;
            
            const centerX = 300;
            const centerY = 260;
            const scaleX = 30;
            const scaleY = 100;
            
            ctx.beginPath();
            let first = true;
            
            for (let omega = -10; omega <= 10; omega += 0.05) {
                let magnitude = 0;
                
                switch(signalType) {
                    case 'rect':
                        magnitude = param * Math.abs(sinc(omega * param / 2));
                        break;
                    case 'exp':
                        magnitude = 1 / Math.sqrt(param * param + omega * omega);
                        break;
                    case 'gaussian':
                        magnitude = Math.sqrt(Math.PI / param) * Math.exp(-omega * omega / (4 * param));
                        break;
                    case 'triangle':
                        const sincValue = sinc(omega * param / 2);
                        magnitude = param * sincValue * sincValue;
                        break;
                }
                
                const x = centerX + omega * scaleX;
                const plotY = centerY - magnitude * scaleY;
                
                if (first) {
                    ctx.moveTo(x, plotY);
                    first = false;
                } else {
                    ctx.lineTo(x, plotY);
                }
            }
            ctx.stroke();
        }
        
        function displayTransformFormula(signalType, param) {
            let formula = '';
            
            switch(signalType) {
                case 'rect':
                    formula = `矩形脉冲 (宽度=${param}):<br>`;
                    formula += `x(t) = rect(t/${param})<br>`;
                    formula += `X(jω) = ${param}·sinc(ω·${param}/2)`;
                    break;
                case 'exp':
                    formula = `单边指数 (衰减常数=${param}):<br>`;
                    formula += `x(t) = e^(-${param}t)u(t)<br>`;
                    formula += `X(jω) = 1/(${param} + jω)`;
                    break;
                case 'gaussian':
                    formula = `高斯脉冲 (参数=${param}):<br>`;
                    formula += `x(t) = e^(-${param}t²)<br>`;
                    formula += `X(jω) = √(π/${param})·e^(-ω²/(4·${param}))`;
                    break;
                case 'triangle':
                    formula = `三角脉冲 (宽度=${param}):<br>`;
                    formula += `x(t) = Λ(t/${param})<br>`;
                    formula += `X(jω) = ${param}·sinc²(ω·${param}/2)`;
                    break;
            }
            
            document.getElementById('ftFormula').innerHTML = formula;
        }
        
        // 典型信号对比
        function updateSignalComparison() {
            const compareType = document.getElementById('compareSignals').value;
            const viewType = document.getElementById('spectrumView').value;
            
            const timeCanvas = document.getElementById('typicalTimeCanvas');
            const freqCanvas = document.getElementById('typicalFreqCanvas');
            const timeCtx = timeCanvas.getContext('2d');
            const freqCtx = freqCanvas.getContext('2d');
            
            // 清空画布
            timeCtx.clearRect(0, 0, 700, 350);
            freqCtx.clearRect(0, 0, 700, 350);
            
            // 绘制坐标轴
            drawAxis(timeCtx, 700, 350, 't', 'x(t)');
            drawFrequencyAxis(freqCtx, 700, 350, true);
            
            // 根据选择绘制信号
            if (compareType === 'all') {
                drawAllTypicalSignals(timeCtx, freqCtx, viewType);
            } else {
                drawSignalGroup(timeCtx, freqCtx, compareType, viewType);
            }
        }
        
        function drawAllTypicalSignals(timeCtx, freqCtx, viewType) {
            const signals = [
                {type: 'rect', param: 2, color: colors.primary, name: '矩形'},
                {type: 'exp', param: 1, color: colors.secondary, name: '指数'},
                {type: 'gaussian', param: 1, color: colors.accent, name: '高斯'},
                {type: 'triangle', param: 2, color: colors.success, name: '三角'}
            ];
            
            // 绘制图例
            timeCtx.fillStyle = '#333';
            timeCtx.font = '12px Arial';
            timeCtx.fillText('矩形(蓝) 指数(紫) 高斯(粉) 三角(绿)', 50, 30);
            
            signals.forEach(signal => {
                drawComparisonSignal(timeCtx, freqCtx, signal, viewType);
            });
        }
        
        function drawSignalGroup(timeCtx, freqCtx, group, viewType) {
            let signals = [];
            
            if (group === 'pulse') {
                signals = [
                    {type: 'rect', param: 2, color: colors.primary, name: '矩形'},
                    {type: 'triangle', param: 2, color: colors.success, name: '三角'},
                    {type: 'gaussian', param: 1, color: colors.accent, name: '高斯'}
                ];
            } else if (group === 'exponential') {
                signals = [
                    {type: 'exp', param: 0.5, color: colors.primary, name: 'a=0.5'},
                    {type: 'exp', param: 1, color: colors.secondary, name: 'a=1'},
                    {type: 'exp', param: 2, color: colors.danger, name: 'a=2'}
                ];
            }
            
            signals.forEach(signal => {
                drawComparisonSignal(timeCtx, freqCtx, signal, viewType);
            });
        }
        
        function drawComparisonSignal(timeCtx, freqCtx, signal, viewType) {
            const {type, param, color} = signal;
            
            // 时域信号
            timeCtx.strokeStyle = color;
            timeCtx.lineWidth = 2;
            timeCtx.beginPath();
            
            const centerX = 350;
            const centerY = 175;
            const scaleX = 40;
            const scaleY = 60;
            
            let first = true;
            for (let t = -6; t <= 6; t += 0.05) {
                let y = 0;
                
                switch(type) {
                    case 'rect':
                        y = rect(t, param);
                        break;
                    case 'exp':
                        y = (t >= 0) ? Math.exp(-param * t) : 0;
                        break;
                    case 'gaussian':
                        y = Math.exp(-param * t * t);
                        break;
                    case 'triangle':
                        y = triangle(t, param);
                        break;
                }
                
                const x = centerX + t * scaleX;
                const plotY = centerY - y * scaleY;
                
                if (first) {
                    timeCtx.moveTo(x, plotY);
                    first = false;
                } else {
                    timeCtx.lineTo(x, plotY);
                }
            }
            timeCtx.stroke();
            
            // 频域信号
            if (viewType === 'magnitude' || viewType === 'both') {
                freqCtx.strokeStyle = color;
                freqCtx.lineWidth = 2;
                freqCtx.beginPath();
                
                const freqCenterY = 310;
                const freqScaleY = 50;
                
                first = true;
                for (let omega = -8; omega <= 8; omega += 0.1) {
                    let magnitude = 0;
                    
                    switch(type) {
                        case 'rect':
                            magnitude = param * Math.abs(sinc(omega * param / 2));
                            break;
                        case 'exp':
                            magnitude = 1 / Math.sqrt(param * param + omega * omega);
                            break;
                        case 'gaussian':
                            magnitude = Math.sqrt(Math.PI / param) * Math.exp(-omega * omega / (4 * param));
                            break;
                        case 'triangle':
                            const sincVal = sinc(omega * param / 2);
                            magnitude = param * sincVal * sincVal;
                            break;
                    }
                    
                    const x = centerX + omega * scaleX;
                    const plotY = freqCenterY - magnitude * freqScaleY;
                    
                    if (first) {
                        freqCtx.moveTo(x, plotY);
                        first = false;
                    } else {
                        freqCtx.lineTo(x, plotY);
                    }
                }
                freqCtx.stroke();
            }
        }
        
        // 性质演示
        function updatePropertyDemo() {
            const property = document.getElementById('propertyDemo').value;
            const param = parseFloat(document.getElementById('propertyParam').value);
            document.getElementById('propertyParamValue').textContent = param;
            
            const originalCanvas = document.getElementById('propertyOriginalCanvas');
            const transformedCanvas = document.getElementById('propertyTransformedCanvas');
            const originalCtx = originalCanvas.getContext('2d');
            const transformedCtx = transformedCanvas.getContext('2d');
            
            // 绘制原信号
            drawAxis(originalCtx, 500, 300, 't', 'x(t)');
            drawBaseSignal(originalCtx, 'rect', 2); // 基础矩形信号
            
            // 绘制变换后信号
            drawAxis(transformedCtx, 500, 300, 't', 'y(t)');
            drawTransformedSignal(transformedCtx, property, param);
            
            // 显示说明
            displayPropertyExplanation(property, param);
        }
        
        function drawBaseSignal(ctx, type, param) {
            ctx.strokeStyle = colors.info;
            ctx.lineWidth = 3;
            
            const centerX = 250;
            const centerY = 150;
            const scaleX = 40;
            const scaleY = 60;
            
            ctx.beginPath();
            let first = true;
            
            for (let t = -5; t <= 5; t += 0.05) {
                const y = rect(t, param);
                const x = centerX + t * scaleX;
                const plotY = centerY - y * scaleY;
                
                if (first) {
                    ctx.moveTo(x, plotY);
                    first = false;
                } else {
                    ctx.lineTo(x, plotY);
                }
            }
            ctx.stroke();
        }
        
        function drawTransformedSignal(ctx, property, param) {
            ctx.strokeStyle = colors.danger;
            ctx.lineWidth = 3;
            
            const centerX = 250;
            const centerY = 150;
            const scaleX = 40;
            const scaleY = 60;
            
            ctx.beginPath();
            let first = true;
            
            for (let t = -5; t <= 5; t += 0.05) {
                let y = 0;
                
                switch(property) {
                    case 'timeshift':
                        y = rect(t - param, 2);
                        break;
                    case 'freqshift':
                        y = rect(t, 2) * Math.cos(param * t);
                        break;
                    case 'scaling':
                        y = rect(param * t, 2);
                        break;
                    case 'convolution':
                        // 简化的卷积演示
                        y = calculateSimpleConvolution(t, param);
                        break;
                }
                
                const x = centerX + t * scaleX;
                const plotY = centerY - y * scaleY;
                
                if (first) {
                    ctx.moveTo(x, plotY);
                    first = false;
                } else {
                    ctx.lineTo(x, plotY);
                }
            }
            ctx.stroke();
        }
        
        function calculateSimpleConvolution(t, param) {
            // 矩形与指数的卷积的简化计算
            if (t < -1) return 0;
            if (t < 1) return (1 - Math.exp(-param * (t + 1))) / param;
            return (Math.exp(-param * (t - 1)) - Math.exp(-param * (t + 1))) / param;
        }
        
        function displayPropertyExplanation(property, param) {
            let explanation = '';
            
            switch(property) {
                case 'timeshift':
                    explanation = `时移性质演示：x(t - ${param})<br>`;
                    explanation += `傅里叶变换：X(jω)e^(-jω·${param})<br>`;
                    explanation += `影响：只改变相位谱，不改变幅度谱`;
                    break;
                case 'freqshift':
                    explanation = `频移性质演示：x(t)cos(${param}t)<br>`;
                    explanation += `傅里叶变换：[X(j(ω-${param})) + X(j(ω+${param}))]/2<br>`;
                    explanation += `应用：调制技术的基础`;
                    break;
                case 'scaling':
                    explanation = `尺度变换演示：x(${param}t)<br>`;
                    explanation += `傅里叶变换：(1/${Math.abs(param)})X(jω/${param})<br>`;
                    explanation += `规律：时域压缩，频域扩展`;
                    break;
                case 'convolution':
                    explanation = `卷积定理演示：x(t) * h(t)<br>`;
                    explanation += `h(t) = e^(-${param}t)u(t)<br>`;
                    explanation += `频域：X(jω)H(jω)`;
                    break;
            }
            
            document.getElementById('propertyExplanation').innerHTML = explanation;
        }
        
        // 周期信号的傅里叶变换
        function updatePeriodicFT() {
            const signal = document.getElementById('periodicSignal').value;
            const T = parseFloat(document.getElementById('periodValue').value);
            const duty = parseFloat(document.getElementById('dutyRatio').value);
            document.getElementById('periodValueLabel').textContent = T;
            document.getElementById('dutyRatioLabel').textContent = duty;
            
            const timeCanvas = document.getElementById('periodicTimeCanvas');
            const freqCanvas = document.getElementById('periodicFreqCanvas');
            const spectrumCanvas = document.getElementById('periodicSpectrumCanvas');
            
            const timeCtx = timeCanvas.getContext('2d');
            const freqCtx = freqCanvas.getContext('2d');
            const spectrumCtx = spectrumCanvas.getContext('2d');
            
            // 绘制时域信号
            drawAxis(timeCtx, 600, 250, 't', 'x(t)');
            drawPeriodicTimeSignal(timeCtx, signal, T, duty);
            
            // 绘制频域（冲激函数表示）
            drawFrequencyAxis(freqCtx, 600, 250, true);
            drawPeriodicFrequencySpectrum(freqCtx, signal, T, duty);
            
            // 绘制包络线
            drawAxis(spectrumCtx, 600, 250, 'ω', '包络');
            drawSpectrumEnvelope(spectrumCtx, signal, T, duty);
            
            // 分析结果
            analyzePeriodicSpectrum(signal, T, duty);
        }
        
        function drawPeriodicTimeSignal(ctx, signalType, T, duty) {
            ctx.strokeStyle = colors.primary;
            ctx.lineWidth = 3;
            
            const centerX = 300;
            const centerY = 125;
            const scaleX = 80;
            const scaleY = 60;
            
            ctx.beginPath();
            let first = true;
            
            for (let t = -3*T; t <= 3*T; t += 0.01) {
                let y = 0;
                const tMod = ((t % T) + T) % T;
                
                switch(signalType) {
                    case 'impulse_train':
                        // 用细线表示冲激
                        y = 0;
                        break;
                    case 'square_wave':
                        y = (tMod < duty * T) ? 1 : -1;
                        break;
                    case 'sawtooth_wave':
                        y = (2 * tMod / T) - 1;
                        break;
                }
                
                const x = centerX + t * scaleX / T;
                const plotY = centerY - y * scaleY;
                
                if (first) {
                    ctx.moveTo(x, plotY);
                    first = false;
                } else {
                    ctx.lineTo(x, plotY);
                }
            }
            ctx.stroke();
            
            // 特殊处理冲激串
            if (signalType === 'impulse_train') {
                ctx.strokeStyle = colors.danger;
                ctx.lineWidth = 2;
                for (let n = -3; n <= 3; n++) {
                    const x = centerX + n * scaleX;
                    ctx.beginPath();
                    ctx.moveTo(x, centerY);
                    ctx.lineTo(x, centerY - scaleY);
                    ctx.stroke();
                    
                    // 箭头
                    ctx.beginPath();
                    ctx.moveTo(x, centerY - scaleY);
                    ctx.lineTo(x - 3, centerY - scaleY + 6);
                    ctx.lineTo(x + 3, centerY - scaleY + 6);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }
        
        function drawPeriodicFrequencySpectrum(ctx, signalType, T, duty) {
            ctx.strokeStyle = colors.secondary;
            ctx.lineWidth = 3;
            
            const centerX = 300;
            const centerY = 210;
            const omega0 = 2 * Math.PI / T;
            const scaleX = 30;
            const scaleY = 100;
            
            // 绘制频谱线（冲激函数）
            for (let n = -10; n <= 10; n++) {
                if (n === 0 && signalType !== 'square_wave') continue;
                
                let amplitude = 0;
                const omega = n * omega0;
                
                switch(signalType) {
                    case 'impulse_train':
                        amplitude = 1;
                        break;
                    case 'square_wave':
                        if (n === 0) {
                            amplitude = 0; // 假设对称方波
                        } else if (n % 2 === 1) {
                            amplitude = Math.abs(sinc(n * duty * Math.PI));
                        }
                        break;
                    case 'sawtooth_wave':
                        if (n !== 0) {
                            amplitude = 1 / Math.abs(n);
                        }
                        break;
                }
                
                if (amplitude > 0.05) { // 只显示显著的谱线
                    const x = centerX + omega * scaleX / omega0;
                    const lineHeight = amplitude * scaleY;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, centerY);
                    ctx.lineTo(x, centerY - lineHeight);
                    ctx.stroke();
                    
                    // 标记冲激
                    ctx.fillStyle = colors.secondary;
                    ctx.beginPath();
                    ctx.arc(x, centerY - lineHeight, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
        }
        
        function drawSpectrumEnvelope(ctx, signalType, T, duty) {
            ctx.strokeStyle = colors.accent;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            const centerX = 300;
            const centerY = 210;
            const omega0 = 2 * Math.PI / T;
            const scaleX = 30;
            const scaleY = 100;
            
            ctx.beginPath();
            let first = true;
            
            for (let omega = -20 * omega0; omega <= 20 * omega0; omega += omega0/10) {
                let envelope = 0;
                
                switch(signalType) {
                    case 'impulse_train':
                        envelope = 1;
                        break;
                    case 'square_wave':
                        envelope = Math.abs(sinc(omega * duty * T / 2));
                        break;
                    case 'sawtooth_wave':
                        envelope = (omega !== 0) ? 1 / Math.abs(omega / omega0) : 0;
                        break;
                }
                
                const x = centerX + omega * scaleX / omega0;
                const plotY = centerY - envelope * scaleY;
                
                if (first) {
                    ctx.moveTo(x, plotY);
                    first = false;
                } else {
                    ctx.lineTo(x, plotY);
                }
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function analyzePeriodicSpectrum(signalType, T, duty) {
            const omega0 = 2 * Math.PI / T;
            const f0 = 1 / T;
            
            let analysis = `<strong>周期信号频谱分析:</strong><br>`;
            analysis += `周期 T = ${T}, 基频 f₀ = ${f0.toFixed(2)} Hz<br>`;
            analysis += `基波角频率 Ω = ${omega0.toFixed(2)} rad/s<br><br>`;
            
            switch(signalType) {
                case 'impulse_train':
                    analysis += `冲激串的频谱：<br>`;
                    analysis += `X(jω) = (2π/T)∑δ(ω - nΩ)<br>`;
                    analysis += `特点：时域周期 = 频域周期`;
                    break;
                case 'square_wave':
                    analysis += `周期方波的频谱：<br>`;
                    analysis += `只含奇次谐波，幅度按sinc函数衰减<br>`;
                    analysis += `占空比 = ${duty}，影响频谱包络`;
                    break;
                case 'sawtooth_wave':
                    analysis += `周期锯齿波的频谱：<br>`;
                    analysis += `含所有谐波，幅度按1/n衰减<br>`;
                    analysis += `相位为-π/2（纯虚数）`;
                    break;
            }
            
            document.getElementById('periodicAnalysis').innerHTML = analysis;
        }
        
        // 应用演示
        function updateApplicationDemo() {
            const app = document.getElementById('applicationDemo').value;
            const param = parseFloat(document.getElementById('appParam').value);
            document.getElementById('appParamValue').textContent = param;
            
            const inputCanvas = document.getElementById('appInputCanvas');
            const outputCanvas = document.getElementById('appOutputCanvas');
            const spectrumCanvas = document.getElementById('appSpectrumCanvas');
            
            const inputCtx = inputCanvas.getContext('2d');
            const outputCtx = outputCanvas.getContext('2d');
            const spectrumCtx = spectrumCanvas.getContext('2d');
            
            switch(app) {
                case 'filtering':
                    demonstrateFiltering(inputCtx, outputCtx, spectrumCtx, param);
                    break;
                case 'modulation':
                    demonstrateModulation(inputCtx, outputCtx, spectrumCtx, param);
                    break;
                case 'sampling':
                    demonstrateSampling(inputCtx, outputCtx, spectrumCtx, param);
                    break;
            }
        }
        
        function demonstrateFiltering(inputCtx, outputCtx, spectrumCtx, cutoffFreq) {
            // 输入信号：含噪声的信号
            drawAxis(inputCtx, 500, 200, 't', '输入');
            drawNoisySignal(inputCtx, cutoffFreq);
            
            // 输出信号：滤波后的信号
            drawAxis(outputCtx, 500, 200, 't', '输出');
            drawFilteredSignal(outputCtx, cutoffFreq);
            
            // 频谱：滤波器响应
            drawFrequencyAxis(spectrumCtx, 500, 200, true);
            drawFilterResponse(spectrumCtx, cutoffFreq);
            
            document.getElementById('applicationAnalysis').innerHTML = `
                <strong>低通滤波演示:</strong><br>
                截止频率 = ${cutoffFreq} rad/s<br>
                高频噪声被滤除，保留低频信号分量
            `;
        }
        
        function drawNoisySignal(ctx, param) {
            ctx.strokeStyle = colors.primary;
            ctx.lineWidth = 2;
            
            const centerX = 250;
            const centerY = 100;
            const scaleX = 40;
            const scaleY = 30;
            
            ctx.beginPath();
            let first = true;
            
            for (let t = -5; t <= 5; t += 0.02) {
                // 低频信号 + 高频噪声
                const signal = Math.sin(t) + 0.3 * Math.sin(5 * t) + 0.1 * Math.sin(10 * t);
                
                const x = centerX + t * scaleX;
                const plotY = centerY - signal * scaleY;
                
                if (first) {
                    ctx.moveTo(x, plotY);
                    first = false;
                } else {
                    ctx.lineTo(x, plotY);
                }
            }
            ctx.stroke();
        }
        
        function drawFilteredSignal(ctx, cutoffFreq) {
            ctx.strokeStyle = colors.success;
            ctx.lineWidth = 2;
            
            const centerX = 250;
            const centerY = 100;
            const scaleX = 40;
            const scaleY = 30;
            
            ctx.beginPath();
            let first = true;
            
            for (let t = -5; t <= 5; t += 0.02) {
                // 模拟低通滤波效果
                let signal = Math.sin(t);
                if (cutoffFreq > 3) signal += 0.3 * Math.sin(5 * t);
                if (cutoffFreq > 8) signal += 0.1 * Math.sin(10 * t);
                
                const x = centerX + t * scaleX;
                const plotY = centerY - signal * scaleY;
                
                if (first) {
                    ctx.moveTo(x, plotY);
                    first = false;
                } else {
                    ctx.lineTo(x, plotY);
                }
            }
            ctx.stroke();
        }
        
        function drawFilterResponse(ctx, cutoffFreq) {
            ctx.strokeStyle = colors.info;
            ctx.lineWidth = 3;
            
            const centerX = 250;
            const centerY = 170;
            const scaleX = 20;
            const scaleY = 80;
            
            ctx.beginPath();
            let first = true;
            
            for (let omega = -15; omega <= 15; omega += 0.1) {
                // 理想低通滤波器
                const magnitude = (Math.abs(omega) <= cutoffFreq) ? 1 : 0;
                
                const x = centerX + omega * scaleX;
                const plotY = centerY - magnitude * scaleY;
                
                if (first) {
                    ctx.moveTo(x, plotY);
                    first = false;
                } else {
                    ctx.lineTo(x, plotY);
                }
            }
            ctx.stroke();
        }
        
        function demonstrateModulation(inputCtx, outputCtx, spectrumCtx, carrierFreq) {
            // 类似的实现...
            document.getElementById('applicationAnalysis').innerHTML = `
                <strong>AM调制演示:</strong><br>
                载波频率 = ${carrierFreq} rad/s<br>
                信号频谱搬移到载波频率附近
            `;
        }
        
        function demonstrateSampling(inputCtx, outputCtx, spectrumCtx, samplingRate) {
            // 类似的实现...
            document.getElementById('applicationAnalysis').innerHTML = `
                <strong>采样定理演示:</strong><br>
                采样率 = ${samplingRate} Hz<br>
                需满足 fs ≥ 2fm 以避免混叠
            `;
        }
        
        // 练习题答案检查
        function checkAnswer1() {
            const answer = document.getElementById('answer1').value;
            const feedback = document.getElementById('feedback1');
            
            if (answer === 'sinc') {
                feedback.textContent = '正确！矩形脉冲的傅里叶变换是sinc函数。';
                feedback.className = 'feedback correct';
            } else {
                feedback.textContent = '错误。矩形脉冲x(t) = rect(t/T)的傅里叶变换是X(jω) = T·sinc(ωT/2)。';
                feedback.className = 'feedback incorrect';
            }
            feedback.style.display = 'block';
        }
        
        function checkAnswer2() {
            const answer = document.getElementById('answer2').value;
            const feedback = document.getElementById('feedback2');
            
            if (answer === 'double') {
                feedback.textContent = '正确！时域压缩一半，频域扩展一倍。这体现了时频域的反比关系。';
                feedback.className = 'feedback correct';
            } else {
                feedback.textContent = '错误。根据尺度变换性质，时域压缩，频域扩展。宽度减半，主瓣宽度增加一倍。';
                feedback.className = 'feedback incorrect';
            }
            feedback.style.display = 'block';
        }
        
        function checkAnswer3() {
            const answer = document.getElementById('answer3').value;
            const feedback = document.getElementById('feedback3');
            
            if (answer === 'half_X_half_w') {
                feedback.textContent = '正确！根据尺度变换性质：x(at) ↔ (1/|a|)X(jω/a)，所以x(2t) ↔ (1/2)X(jω/2)。';
                feedback.className = 'feedback correct';
            } else {
                feedback.textContent = '错误。尺度变换性质：x(at) ↔ (1/|a|)X(jω/a)，因此x(2t) ↔ (1/2)X(jω/2)。';
                feedback.className = 'feedback incorrect';
            }
            feedback.style.display = 'block';
        }
        
        function checkAnswer4() {
            const answer = document.getElementById('answer4').value.toLowerCase();
            const feedback = document.getElementById('feedback4');
            
            if (answer.includes('2π/t') || answer.includes('2pi/t') || answer.includes('ω0') || answer.includes('omega')) {
                feedback.textContent = '正确！周期为T的冲激串，频域中相邻冲激的间隔是Ω = 2π/T。';
                feedback.className = 'feedback correct';
            } else {
                feedback.textContent = '错误。周期为T的冲激串的傅里叶变换中，相邻冲激的间隔是基波角频率Ω = 2π/T。';
                feedback.className = 'feedback incorrect';
            }
            feedback.style.display = 'block';
        }
        
        function checkAnswer5() {
            const answer = parseFloat(document.getElementById('answer5').value);
            const feedback = document.getElementById('feedback5');
            
            // x(t) = e^(-2|t|) 的傅里叶变换是 X(jω) = 4/(4 + ω²)
            // 在 ω=1 处，X(j1) = 4/(4 + 1) = 4/5 = 0.8
            const correct = 4 / (4 + 1);
            
            if (Math.abs(answer - correct) < 0.01) {
                feedback.textContent = `正确！X(j1) = 4/(4 + 1²) = 4/5 = 0.8`;
                feedback.className = 'feedback correct';
            } else {
                feedback.textContent = `错误。x(t) = e^(-2|t|)的傅里叶变换是X(jω) = 4/(4 + ω²)，所以X(j1) = 4/5 = 0.8`;
                feedback.className = 'feedback incorrect';
            }
            feedback.style.display = 'block';
        }
        
        // 初始化
        window.onload = function() {
            updateFourierTransform();
            updateSignalComparison();
            updatePropertyDemo();
            updatePeriodicFT();
            updateApplicationDemo();
        };
        
        // 事件监听器
        document.getElementById('ftParam').addEventListener('input', updateFourierTransform);
        document.getElementById('propertyParam').addEventListener('input', updatePropertyDemo);
        document.getElementById('periodValue').addEventListener('input', updatePeriodicFT);
        document.getElementById('dutyRatio').addEventListener('input', updatePeriodicFT);
        document.getElementById('appParam').addEventListener('input', updateApplicationDemo);
    </script>
</body>
</html>
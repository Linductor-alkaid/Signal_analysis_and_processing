<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>信号分析与处理 - FIR数字滤波器的设计</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 30px;
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }
        
        h2 {
            color: #34495e;
            border-left: 4px solid #3498db;
            padding-left: 15px;
            margin-top: 30px;
        }
        
        h3 {
            color: #2980b9;
            margin-top: 25px;
        }
        
        .knowledge-point {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }
        
        .formula {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            font-family: 'Times New Roman', serif;
            font-size: 18px;
        }
        
        .important {
            background: #ffeaa7;
            border: 2px solid #fdcb6e;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .example {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .plot-container {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }
        
        canvas {
            border: 1px solid #ccc;
            margin: 10px;
        }
        
        .controls {
            margin: 15px 0;
            text-align: center;
        }
        
        .controls input, .controls select {
            margin: 5px;
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .controls button {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        
        .controls button:hover {
            background: #2980b9;
        }
        
        .exercise {
            background: #e8f5e8;
            border: 1px solid #c3e6c3;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .exercise h4 {
            color: #2e7d2e;
            margin-top: 0;
        }
        
        .answer {
            background: #f0f0f0;
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
            display: none;
        }
        
        .show-answer {
            background: #28a745;
            color: white;
            border: none;
            padding: 5px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        
        .show-answer:hover {
            background: #218838;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        th {
            background: #f2f2f2;
        }
        
        .highlight {
            background: #ffeb3b;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .fir-box {
            background: #e8f5e8;
            border: 2px solid #4caf50;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .window-box {
            background: #f3e5f5;
            border: 2px solid #9c27b0;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .sampling-box {
            background: #e3f2fd;
            border: 2px solid #2196f3;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }
        
        .linear-phase-demo {
            background: #fff8e1;
            border: 1px solid #ffb74d;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .window-types {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .window-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }
        
        .design-steps {
            background: #f0f8ff;
            border: 1px solid #87ceeb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .design-steps ol {
            margin: 0;
            padding-left: 20px;
        }
        
        .frequency-sampling-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-table {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .phase-types {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        
        .phase-type {
            background: #f0f8ff;
            border: 1px solid #87ceeb;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>信号分析与处理 - FIR数字滤波器的设计</h1>
        
        <div class="important">
            <h3>🎯 FIR滤波器基本概念</h3>
            <p>FIR (Finite Impulse Response) 数字滤波器：<strong>有限冲激响应滤波器</strong>，其冲激响应h[n]在有限个采样点后为零。</p>
            <div class="formula">
                H(z) = ∑(n=0 to N-1) h[n]z^{-n}
            </div>
            <p>主要特点：<strong>系统稳定、可实现严格线性相位、无反馈</strong></p>
        </div>
        
        <h2>1. 线性相位FIR数字滤波器的特点</h2>
        
        <div class="fir-box">
            <h3>🟢 线性相位的定义与意义</h3>
            <p><strong>线性相位</strong>是指频率响应的相位ϕ(ω)与频率ω成正比关系：</p>
            <div class="formula">
                ϕ(ω) = -αω + β
            </div>
            <p>其中α为常数（群延迟），β为0或π。</p>
            
            <div class="example">
                <h4>线性相位的重要性</h4>
                <ul>
                    <li><strong>无相位失真</strong>：各频率分量经过滤波器后的相对时延相同</li>
                    <li><strong>波形保持</strong>：输入信号波形在滤波后基本保持不变</li>
                    <li><strong>应用领域</strong>：音频处理、图像处理、通信系统等</li>
                </ul>
            </div>
        </div>
        
        <div class="knowledge-point">
            <h3>线性相位条件</h3>
            <p>FIR滤波器具有线性相位的<strong>充要条件</strong>是其冲激响应具有特定的对称性：</p>
            
            <div class="phase-types">
                <div class="phase-type">
                    <h4>第一类线性相位</h4>
                    <div class="formula">h[n] = h[N-1-n]</div>
                    <p><strong>偶对称</strong>，N为奇数</p>
                    <p>β = 0，适合所有滤波器类型</p>
                </div>
                <div class="phase-type">
                    <h4>第二类线性相位</h4>
                    <div class="formula">h[n] = h[N-1-n]</div>
                    <p><strong>偶对称</strong>，N为偶数</p>
                    <p>β = 0，不适合高通滤波器</p>
                </div>
                <div class="phase-type">
                    <h4>第三类线性相位</h4>
                    <div class="formula">h[n] = -h[N-1-n]</div>
                    <p><strong>奇对称</strong>，N为奇数</p>
                    <p>β = π/2，适合微分器、Hilbert变换器</p>
                </div>
                <div class="phase-type">
                    <h4>第四类线性相位</h4>
                    <div class="formula">h[n] = -h[N-1-n]</div>
                    <p><strong>奇对称</strong>，N为偶数</p>
                    <p>β = π/2，适合微分器</p>
                </div>
            </div>
        </div>
        
        <div class="linear-phase-demo">
            <h3>📊 群延迟特性</h3>
            <p>线性相位FIR滤波器的<strong>群延迟</strong>为常数：</p>
            <div class="formula">
                τ_g = -dϕ(ω)/dω = α = (N-1)/2
            </div>
            <p>这意味着所有频率分量都有相同的时延，保证了信号波形不失真。</p>
        </div>
        
        <div class="plot-container">
            <h3>线性相位特性演示</h3>
            <canvas id="linearPhaseDemo" width="800" height="400"></canvas>
            <div class="controls">
                <label>滤波器长度N：</label>
                <input type="range" id="filterLength" min="5" max="31" step="2" value="15">
                <span id="lengthValue">15</span>
                <label>对称类型：</label>
                <select id="symmetryType">
                    <option value="even">偶对称</option>
                    <option value="odd">奇对称</option>
                </select>
                <button onclick="updateLinearPhase()">更新演示</button>
            </div>
        </div>
        
        <h2>2. 窗函数法设计FIR数字滤波器</h2>
        
        <div class="window-box">
            <h3>🟣 基本设计思想</h3>
            <p>窗函数法的核心思想：从<strong>理想滤波器的冲激响应</strong>出发，通过<strong>窗函数加权截断</strong>得到有限长度的FIR滤波器。</p>
            
            <h4>设计步骤</h4>
            <div class="design-steps">
                <ol>
                    <li><strong>确定理想响应</strong>：根据技术指标确定理想滤波器H_d(e^{jω})</li>
                    <li><strong>求理想冲激响应</strong>：通过IDTFT得到h_d[n]</li>
                    <li><strong>选择窗函数</strong>：根据技术要求选择合适的窗函数w[n]</li>
                    <li><strong>截断加权</strong>：h[n] = h_d[n] · w[n]</li>
                    <li><strong>验证性能</strong>：检查设计结果是否满足指标</li>
                </ol>
            </div>
        </div>
        
        <div class="knowledge-point">
            <h3>理想滤波器的冲激响应</h3>
            
            <h4>理想低通滤波器</h4>
            <div class="formula">
                h_d[n] = (sin(ω_c n))/(πn), n ≠ 0<br>
                h_d[0] = ω_c/π
            </div>
            <p>其中ω_c为截止频率。</p>
            
            <h4>其他类型滤波器</h4>
            <div class="example">
                <ul>
                    <li><strong>高通</strong>：h_d[n] = δ[n] - h_{lp}[n]</li>
                    <li><strong>带通</strong>：h_d[n] = h_{lp1}[n] - h_{lp2}[n]</li>
                    <li><strong>带阻</strong>：h_d[n] = δ[n] - h_{bp}[n]</li>
                </ul>
            </div>
        </div>
        
        <div class="knowledge-point">
            <h3>常用窗函数及其特性</h3>
            
            <div class="window-types">
                <div class="window-item">
                    <h4>矩形窗</h4>
                    <div class="formula">w[n] = 1, 0 ≤ n ≤ N-1</div>
                    <p><strong>主瓣宽度</strong>：4π/N</p>
                    <p><strong>旁瓣衰减</strong>：-13dB</p>
                    <p><strong>特点</strong>：过渡带窄，阻带衰减小</p>
                </div>
                
                <div class="window-item">
                    <h4>汉宁窗</h4>
                    <div class="formula">w[n] = 0.5[1 - cos(2πn/(N-1))]</div>
                    <p><strong>主瓣宽度</strong>：8π/N</p>
                    <p><strong>旁瓣衰减</strong>：-31dB</p>
                    <p><strong>特点</strong>：旁瓣衰减快</p>
                </div>
                
                <div class="window-item">
                    <h4>海明窗</h4>
                    <div class="formula">w[n] = 0.54 - 0.46cos(2πn/(N-1))</div>
                    <p><strong>主瓣宽度</strong>：8π/N</p>
                    <p><strong>旁瓣衰减</strong>：-41dB</p>
                    <p><strong>特点</strong>：综合性能好</p>
                </div>
                
                <div class="window-item">
                    <h4>布拉克曼窗</h4>
                    <div class="formula">w[n] = 0.42 - 0.5cos(2πn/(N-1)) + 0.08cos(4πn/(N-1))</div>
                    <p><strong>主瓣宽度</strong>：12π/N</p>
                    <p><strong>旁瓣衰减</strong>：-57dB</p>
                    <p><strong>特点</strong>：阻带衰减大</p>
                </div>
                
                <div class="window-item">
                    <h4>凯泽窗</h4>
                    <div class="formula">w[n] = I_0(β√(1-((n-(N-1)/2)/((N-1)/2))^2))/I_0(β)</div>
                    <p><strong>参数</strong>：β可调</p>
                    <p><strong>特点</strong>：最优化窗函数</p>
                    <p><strong>优势</strong>：可调节过渡带和阻带衰减</p>
                </div>
                
                <div class="window-item">
                    <h4>切比雪夫窗</h4>
                    <div class="formula">基于切比雪夫多项式</div>
                    <p><strong>参数</strong>：阻带衰减可指定</p>
                    <p><strong>特点</strong>：等纹波特性</p>
                    <p><strong>优势</strong>：在给定长度下阻带衰减最大</p>
                </div>
            </div>
        </div>
        
        <div class="important">
            <h3>⚖️ 窗函数选择准则</h3>
            <div class="comparison-grid">
                <div class="comparison-item">
                    <h4>性能权衡</h4>
                    <ul>
                        <li><strong>过渡带宽度</strong> ∝ 主瓣宽度</li>
                        <li><strong>阻带衰减</strong> ∝ 旁瓣衰减</li>
                        <li><strong>滤波器长度</strong> ∝ 性能要求</li>
                    </ul>
                </div>
                <div class="comparison-item">
                    <h4>选择建议</h4>
                    <ul>
                        <li><strong>矩形窗</strong>：过渡带要求严格</li>
                        <li><strong>汉宁/海明窗</strong>：一般应用</li>
                        <li><strong>凯泽窗</strong>：最优设计</li>
                        <li><strong>切比雪夫窗</strong>：阻带衰减严格</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="plot-container">
            <h3>窗函数法设计演示</h3>
            <canvas id="windowMethodDemo" width="800" height="500"></canvas>
            <div class="controls">
                <label>窗函数类型：</label>
                <select id="windowType">
                    <option value="rectangular">矩形窗</option>
                    <option value="hanning">汉宁窗</option>
                    <option value="hamming">海明窗</option>
                    <option value="blackman">布拉克曼窗</option>
                    <option value="kaiser">凯泽窗</option>
                </select>
                <label>滤波器长度：</label>
                <input type="range" id="windowLength" min="11" max="101" step="10" value="31">
                <span id="windowLengthValue">31</span>
                <label>截止频率：</label>
                <input type="range" id="cutoffFreq" min="0.1" max="0.9" step="0.1" value="0.3">
                <span id="cutoffValue">0.3</span>π
                <label>β参数(凯泽窗)：</label>
                <input type="range" id="kaiserBeta" min="1" max="10" step="0.5" value="5">
                <span id="betaValue">5</span>
                <button onclick="updateWindowMethod()">更新设计</button>
            </div>
        </div>
        
        <h2>3. 频率抽样法设计FIR数字滤波器</h2>
        
        <div class="sampling-box">
            <h3>🔵 基本原理</h3>
            <p>频率抽样法的核心思想：在<strong>频率域对理想响应进行等间隔抽样</strong>，然后通过IDFT得到时域冲激响应。</p>
            
            <h4>设计公式</h4>
            <div class="formula">
                H[k] = H_d(e^{j2πk/N}), k = 0, 1, ..., N-1<br>
                h[n] = (1/N) ∑(k=0 to N-1) H[k]e^{j2πkn/N}
            </div>
        </div>
        
        <div class="knowledge-point">
            <h3>设计步骤与特点</h3>
            
            <div class="design-steps">
                <h4>🔧 具体设计步骤</h4>
                <ol>
                    <li><strong>确定滤波器长度N</strong>：根据技术指标选择</li>
                    <li><strong>频率抽样</strong>：在ω = 2πk/N处对理想响应抽样</li>
                    <li><strong>过渡带处理</strong>：对过渡带抽样点进行优化</li>
                    <li><strong>IDFT计算</strong>：求得h[n]</li>
                    <li><strong>性能优化</strong>：调整过渡带抽样值</li>
                </ol>
            </div>
            
            <div class="example">
                <h4>频率抽样的特点</h4>
                <ul>
                    <li><strong>精确匹配</strong>：在抽样点处频率响应完全匹配理想值</li>
                    <li><strong>过渡带控制</strong>：可通过优化过渡带抽样值改善性能</li>
                    <li><strong>计算简便</strong>：直接使用DFT/FFT算法</li>
                    <li><strong>设计灵活</strong>：可任意指定频率响应形状</li>
                </ul>
            </div>
        </div>
        
        <div class="knowledge-point">
            <h3>过渡带优化</h3>
            <p>在过渡带区域，可以通过优化抽样值来改善滤波器性能：</p>
            
            <h4>优化目标</h4>
            <div class="formula">
                min{max|H(e^{jω}) - H_d(e^{jω})|} for ω ∈ 过渡带
            </div>
            
            <div class="frequency-sampling-grid">
                <div class="comparison-item">
                    <h4>传统方法</h4>
                    <ul>
                        <li>过渡带抽样值设为0.5</li>
                        <li>简单但非最优</li>
                        <li>可能出现较大纹波</li>
                    </ul>
                </div>
                <div class="comparison-item">
                    <h4>优化方法</h4>
                    <ul>
                        <li>使用线性规划或梯度算法</li>
                        <li>最小化最大误差</li>
                        <li>获得更好的阻带衰减</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="plot-container">
            <h3>频率抽样法设计演示</h3>
            <canvas id="frequencySamplingDemo" width="800" height="500"></canvas>
            <div class="controls">
                <label>滤波器长度N：</label>
                <input type="range" id="samplingLength" min="16" max="64" step="8" value="32">
                <span id="samplingLengthValue">32</span>
                <label>通带截止：</label>
                <input type="range" id="passband" min="0.1" max="0.4" step="0.05" value="0.2">
                <span id="passbandValue">0.2</span>π
                <label>阻带起始：</label>
                <input type="range" id="stopband" min="0.4" max="0.8" step="0.05" value="0.6">
                <span id="stopbandValue">0.6</span>π
                <label>过渡带优化：</label>
                <select id="transitionOpt">
                    <option value="simple">简单方法(0.5)</option>
                    <option value="optimized">优化方法</option>
                </select>
                <button onclick="updateFrequencySampling()">更新设计</button>
            </div>
        </div>
        
        <h2>4. IIR与FIR数字滤波器的比较</h2>
        
        <div class="comparison-table">
            <h3>📊 详细性能对比</h3>
            <table>
                <tr>
                    <th rowspan="2">比较项目</th>
                    <th>IIR滤波器</th>
                    <th>FIR滤波器</th>
                </tr>
                <tr>
                    <th>Infinite Impulse Response</th>
                    <th>Finite Impulse Response</th>
                </tr>
                <tr>
                    <td><strong>系统函数</strong></td>
                    <td>H(z) = B(z)/A(z)</td>
                    <td>H(z) = B(z)</td>
                </tr>
                <tr>
                    <td><strong>冲激响应</strong></td>
                    <td>无限长，递减</td>
                    <td>有限长，N个点</td>
                </tr>
                <tr>
                    <td><strong>稳定性</strong></td>
                    <td>可能不稳定</td>
                    <td>总是稳定</td>
                </tr>
                <tr>
                    <td><strong>相位特性</strong></td>
                    <td>非线性相位</td>
                    <td>可实现严格线性相位</td>
                </tr>
                <tr>
                    <td><strong>计算复杂度</strong></td>
                    <td>低（少数乘法器）</td>
                    <td>高（N个乘法器）</td>
                </tr>
                <tr>
                    <td><strong>存储需求</strong></td>
                    <td>少（几个延迟单元）</td>
                    <td>多（N个延迟单元）</td>
                </tr>
                <tr>
                    <td><strong>设计方法</strong></td>
                    <td>模拟原型变换</td>
                    <td>窗函数法、频率抽样法</td>
                </tr>
                <tr>
                    <td><strong>频率选择性</strong></td>
                    <td>好（陡峭过渡带）</td>
                    <td>较差（需要更高阶数）</td>
                </tr>
                <tr>
                    <td><strong>量化敏感性</strong></td>
                    <td>敏感（极点位置）</td>
                    <td>不敏感</td>
                </tr>
                <tr>
                    <td><strong>应用场合</strong></td>
                    <td>对相位要求不严格</td>
                    <td>对相位要求严格</td>
                </tr>
            </table>
        </div>
        
        <div class="important">
            <h3>🎯 选择指导原则</h3>
            
            <div class="comparison-grid">
                <div class="comparison-item">
                    <h4>选择IIR的情况</h4>
                    <ul>
                        <li><strong>实时处理</strong>：计算资源有限</li>
                        <li><strong>存储受限</strong>：内存空间紧张</li>
                        <li><strong>陡峭滤波</strong>：需要窄过渡带</li>
                        <li><strong>经典应用</strong>：音频均衡、抗混叠</li>
                        <li><strong>模拟对应</strong>：有成熟模拟设计</li>
                    </ul>
                </div>
                <div class="comparison-item">
                    <h4>选择FIR的情况</h4>
                    <ul>
                        <li><strong>线性相位</strong>：波形保真度重要</li>
                        <li><strong>数字通信</strong>：符号间干扰敏感</li>
                        <li><strong>图像处理</strong>：空间滤波应用</li>
                        <li><strong>精密测量</strong>：系统稳定性关键</li>
                        <li><strong>自适应滤波</strong>：系数需要调整</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="plot-container">
            <h3>IIR vs FIR性能对比演示</h3>
            <canvas id="iirVsFirDemo" width="800" height="400"></canvas>
            <div class="controls">
                <label>滤波器指标：</label>
                <select id="filterSpec">
                    <option value="lowpass">低通滤波器</option>
                    <option value="bandpass">带通滤波器</option>
                </select>
                <label>通带纹波：</label>
                <input type="range" id="ripple" min="0.1" max="3" step="0.1" value="1">
                <span id="rippleValue">1</span> dB
                <label>阻带衰减：</label>
                <input type="range" id="stopAtten" min="20" max="60" step="5" value="40">
                <span id="stopAttenValue">40</span> dB
                <button onclick="updateComparison()">更新对比</button>
            </div>
            <div id="comparisonResults" style="margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 5px;"></div>
        </div>
        
        <h2>练习题目</h2>
        
        <div class="exercise">
            <h4>练习1：线性相位判断</h4>
            <p>给定FIR滤波器的冲激响应：h[n] = [1, 2, 3, 2, 1]，判断：</p>
            <ol>
                <li>该滤波器是否具有线性相位？</li>
                <li>属于哪一类线性相位？</li>
                <li>计算群延迟。</li>
            </ol>
            <button class="show-answer" onclick="toggleAnswer('answer1')">显示答案</button>
            <div id="answer1" class="answer">
                <strong>答案：</strong><br>
                1. 具有线性相位，因为h[n] = h[4-n]（偶对称）<br>
                2. 第一类线性相位（N=5为奇数，偶对称）<br>
                3. 群延迟 τ_g = (N-1)/2 = (5-1)/2 = 2个采样周期
            </div>
        </div>
        
        <div class="exercise">
            <h4>练习2：窗函数法设计</h4>
            <p>用窗函数法设计低通FIR滤波器，要求：</p>
            <ul>
                <li>截止频率：ω_c = 0.4π</li>
                <li>长度：N = 11</li>
                <li>使用海明窗</li>
            </ul>
            <p>求滤波器系数h[n]。</p>
            <button class="show-answer" onclick="toggleAnswer('answer2')">显示答案</button>
            <div id="answer2" class="answer">
                <strong>答案：</strong><br>
                1. 理想冲激响应：h_d[n] = 0.4sin(0.4π(n-5))/π(n-5)，n≠5；h_d[5] = 0.4<br>
                2. 海明窗：w[n] = 0.54 - 0.46cos(2πn/10)，n = 0,1,...,10<br>
                3. h[n] = h_d[n] × w[n]<br>
                4. 计算得到11个系数，关于n=5点对称
            </div>
        </div>
        
        <div class="exercise">
            <h4>练习3：频率抽样法设计</h4>
            <p>用频率抽样法设计N=8的低通FIR滤波器，理想频率响应：</p>
            <ul>
                <li>H_d[0] = H_d[1] = 1</li>
                <li>H_d[2] = H_d[3] = 0.5（过渡带）</li>
                <li>H_d[4] = H_d[5] = H_d[6] = H_d[7] = 0</li>
            </ul>
            <p>求h[n]的表达式。</p>
            <button class="show-answer" onclick="toggleAnswer('answer3')">显示答案</button>
            <div id="answer3" class="answer">
                <strong>答案：</strong><br>
                使用IDFT公式：h[n] = (1/8)∑(k=0到7) H[k]e^{j2πkn/8}<br>
                = (1/8)[1×1 + 1×e^{jπn/4} + 0.5×e^{jπn/2} + 0.5×e^{j3πn/4}]<br>
                化简后得到实数序列（需要保证线性相位对称性）
            </div>
        </div>
        
        <div class="exercise">
            <h4>练习4：滤波器选择</h4>
            <p>对于以下应用场景，应该选择IIR还是FIR滤波器？说明理由。</p>
            <ol>
                <li>数字音频均衡器</li>
                <li>图像边缘检测滤波器</li>
                <li>心电信号的50Hz陷波器</li>
                <li>数字通信系统中的脉冲成形滤波器</li>
            </ol>
            <button class="show-answer" onclick="toggleAnswer('answer4')">显示答案</button>
            <div id="answer4" class="answer">
                <strong>答案：</strong><br>
                1. IIR - 对相位要求不严格，需要陡峭的频率选择性<br>
                2. FIR - 需要线性相位保持图像细节，避免相位失真<br>
                3. IIR - 窄带陷波器用IIR实现更经济高效<br>
                4. FIR - 通信系统对线性相位要求严格，避免符号间干扰
            </div>
        </div>
        
        <div class="exercise">
            <h4>练习5：窗函数性能分析</h4>
            <p>比较矩形窗、汉宁窗、布拉克曼窗设计同一规格低通滤波器的性能：</p>
            <ul>
                <li>截止频率：ω_c = 0.25π</li>
                <li>长度：N = 21</li>
            </ul>
            <p>分析各窗函数的过渡带宽度和阻带衰减。</p>
            <button class="show-answer" onclick="toggleAnswer('answer5')">显示答案</button>
            <div id="answer5" class="answer">
                <strong>答案：</strong><br>
                <table style="width:100%; border-collapse: collapse;">
                <tr><th>窗函数</th><th>过渡带宽度</th><th>阻带衰减</th><th>特点</th></tr>
                <tr><td>矩形窗</td><td>4π/21≈0.6π</td><td>-13dB</td><td>窄过渡带，低衰减</td></tr>
                <tr><td>汉宁窗</td><td>8π/21≈1.2π</td><td>-31dB</td><td>中等性能</td></tr>
                <tr><td>布拉克曼窗</td><td>12π/21≈1.8π</td><td>-57dB</td><td>宽过渡带，高衰减</td></tr>
                </table>
            </div>
        </div>
        
        <h2>学习要点总结</h2>
        
        <div class="important">
            <h3>🎯 核心掌握要点</h3>
            <ol>
                <li><strong>线性相位</strong>：FIR滤波器的独特优势，理解对称性条件</li>
                <li><strong>窗函数法</strong>：最常用的设计方法，掌握各种窗函数特性</li>
                <li><strong>频率抽样法</strong>：频域设计思路，理解过渡带优化</li>
                <li><strong>IIR vs FIR</strong>：根据应用需求选择合适的滤波器类型</li>
                <li><strong>设计权衡</strong>：过渡带、阻带衰减、滤波器长度的关系</li>
                <li><strong>实现考虑</strong>：计算复杂度、存储需求、量化效应</li>
            </ol>
        </div>
        
        <div class="fir-box">
            <h3>🔗 实用设计建议</h3>
            <ul>
                <li><strong>应用导向</strong>：根据具体应用选择设计方法和参数</li>
                <li><strong>窗函数选择</strong>：凯泽窗通常是最优选择</li>
                <li><strong>长度估计</strong>：可用经验公式估算所需滤波器长度</li>
                <li><strong>性能验证</strong>：设计后必须验证频率响应是否满足指标</li>
                <li><strong>量化考虑</strong>：有限字长实现时考虑系数量化效应</li>
            </ul>
        </div>
    </div>

    <script>
        // 更新线性相位演示
        function updateLinearPhase() {
            const canvas = document.getElementById('linearPhaseDemo');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            const N = parseInt(document.getElementById('filterLength').value);
            const symmetry = document.getElementById('symmetryType').value;
            
            document.getElementById('lengthValue').textContent = N;
            
            ctx.clearRect(0, 0, width, height);
            
            drawLinearPhaseAnalysis(ctx, width, height, N, symmetry);
        }
        
        function drawLinearPhaseAnalysis(ctx, width, height, N, symmetry) {
            const subHeight = height / 2;
            
            // 上半部分：冲激响应
            drawImpulseResponse(ctx, 0, 0, width, subHeight, N, symmetry);
            
            // 下半部分：频率响应
            drawFrequencyResponse(ctx, 0, subHeight, width, subHeight, N, symmetry);
        }
        
        function drawImpulseResponse(ctx, offsetX, offsetY, width, height, N, symmetry) {
            const centerY = offsetY + height * 0.8;
            const scaleX = (width - 60) / N;
            const scaleY = height * 0.4;
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(30, centerY);
            ctx.lineTo(width - 30, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(30, offsetY + 20);
            ctx.lineTo(30, centerY);
            ctx.stroke();
            
            // 绘制冲激响应
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.fillStyle = '#e74c3c';
            
            for (let n = 0; n < N; n++) {
                const x = 30 + n * scaleX + scaleX/2;
                let h_n;
                
                if (symmetry === 'even') {
                    // 偶对称：h[n] = h[N-1-n]
                    const center = (N-1)/2;
                    h_n = 0.5 * Math.exp(-Math.pow((n - center)/3, 2));
                } else {
                    // 奇对称：h[n] = -h[N-1-n]
                    const center = (N-1)/2;
                    h_n = (n - center) * 0.3 * Math.exp(-Math.pow((n - center)/3, 2));
                }
                
                const y = centerY - h_n * scaleY;
                
                // 绘制冲激
                ctx.beginPath();
                ctx.moveTo(x, centerY);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                // 绘制冲激顶点
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // 标题
            ctx.fillStyle = '#e74c3c';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`冲激响应 h[n] (${symmetry === 'even' ? '偶对称' : '奇对称'})`, width/2, offsetY + 15);
            
            // 显示对称性
            const center = (N-1)/2;
            ctx.strokeStyle = '#2ecc71';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(30 + center * scaleX + scaleX/2, offsetY + 30);
            ctx.lineTo(30 + center * scaleX + scaleX/2, centerY - 10);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#2ecc71';
            ctx.font = '10px Arial';
            ctx.fillText('对称轴', 30 + center * scaleX + scaleX/2, offsetY + 25);
        }
        
        function drawFrequencyResponse(ctx, offsetX, offsetY, width, height, N, symmetry) {
            const centerY = offsetY + height * 0.8;
            const scaleX = (width - 60) / Math.PI;
            const scaleY = height * 0.5;
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(30, centerY);
            ctx.lineTo(width - 30, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(30, offsetY + 20);
            ctx.lineTo(30, centerY);
            ctx.stroke();
            
            // 绘制幅度响应
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i <= 200; i++) {
                const omega = (i / 200) * Math.PI;
                const x = 30 + omega * scaleX;
                
                // 计算频率响应
                let magnitude = calculateFIRResponse(omega, N, symmetry);
                
                const y = centerY - magnitude * scaleY;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 绘制相位响应（线性）
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const groupDelay = (N-1)/2;
            const phaseSlope = symmetry === 'even' ? groupDelay : groupDelay + 0.5;
            
            for (let i = 0; i <= 200; i++) {
                const omega = (i / 200) * Math.PI;
                const x = 30 + omega * scaleX;
                const phase = -phaseSlope * omega;
                const normalizedPhase = phase / Math.PI; // 归一化到[-1,1]
                
                const y = centerY - normalizedPhase * scaleY * 0.3;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 标题
            ctx.fillStyle = '#3498db';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('频率响应', width/2, offsetY + 15);
            
            // 图例
            ctx.fillStyle = '#3498db';
            ctx.fillRect(width - 200, offsetY + 30, 20, 3);
            ctx.fillStyle = '#333';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('幅度响应', width - 175, offsetY + 35);
            
            ctx.fillStyle = '#f39c12';
            ctx.fillRect(width - 200, offsetY + 50, 20, 2);
            ctx.fillText('相位响应', width - 175, offsetY + 55);
            
            // 群延迟信息
            ctx.fillStyle = '#2ecc71';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`群延迟: ${groupDelay} 个采样周期`, width/2, offsetY + height - 10);
        }
        
        function calculateFIRResponse(omega, N, symmetry) {
            // 简化的FIR频率响应计算
            let magnitude = 0;
            
            for (let n = 0; n < N; n++) {
                let h_n;
                const center = (N-1)/2;
                
                if (symmetry === 'even') {
                    h_n = 0.5 * Math.exp(-Math.pow((n - center)/3, 2));
                } else {
                    h_n = (n - center) * 0.3 * Math.exp(-Math.pow((n - center)/3, 2));
                }
                
                magnitude += h_n * Math.cos(omega * n);
            }
            
            return Math.abs(magnitude);
        }
        
        // 更新窗函数法演示
        function updateWindowMethod() {
            const canvas = document.getElementById('windowMethodDemo');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            const windowType = document.getElementById('windowType').value;
            const N = parseInt(document.getElementById('windowLength').value);
            const cutoff = parseFloat(document.getElementById('cutoffFreq').value);
            const beta = parseFloat(document.getElementById('kaiserBeta').value);
            
            document.getElementById('windowLengthValue').textContent = N;
            document.getElementById('cutoffValue').textContent = cutoff.toFixed(1);
            document.getElementById('betaValue').textContent = beta;
            
            ctx.clearRect(0, 0, width, height);
            
            drawWindowMethodDemo(ctx, width, height, windowType, N, cutoff, beta);
        }
        
        function drawWindowMethodDemo(ctx, width, height, windowType, N, cutoff, beta) {
            const subHeight = height / 3;
            
            // 上：理想响应
            drawIdealResponse(ctx, 0, 0, width, subHeight, cutoff);
            
            // 中：窗函数
            drawWindowFunction(ctx, 0, subHeight, width, subHeight, windowType, N, beta);
            
            // 下：设计结果
            drawWindowedFilter(ctx, 0, 2*subHeight, width, subHeight, windowType, N, cutoff, beta);
        }
        
        function drawIdealResponse(ctx, offsetX, offsetY, width, height, cutoff) {
            const centerY = offsetY + height * 0.8;
            const scaleX = (width - 60) / Math.PI;
            const scaleY = height * 0.5;
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(30, centerY);
            ctx.lineTo(width - 30, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(30, offsetY + 20);
            ctx.lineTo(30, centerY);
            ctx.stroke();
            
            // 理想低通响应
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            
            const cutoffX = 30 + cutoff * Math.PI * scaleX;
            
            // 通带
            ctx.beginPath();
            ctx.moveTo(30, centerY - scaleY);
            ctx.lineTo(cutoffX, centerY - scaleY);
            ctx.stroke();
            
            // 阻带
            ctx.beginPath();
            ctx.moveTo(cutoffX, centerY);
            ctx.lineTo(width - 30, centerY);
            ctx.stroke();
            
            // 垂直过渡
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(cutoffX, centerY - scaleY);
            ctx.lineTo(cutoffX, centerY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // 标题
            ctx.fillStyle = '#e74c3c';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('理想低通滤波器响应', width/2, offsetY + 15);
        }
        
        function drawWindowFunction(ctx, offsetX, offsetY, width, height, windowType, N, beta) {
            const centerY = offsetY + height * 0.8;
            const scaleX = (width - 60) / N;
            const scaleY = height * 0.5;
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(30, centerY);
            ctx.lineTo(width - 30, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(30, offsetY + 20);
            ctx.lineTo(30, centerY);
            ctx.stroke();
            
            // 绘制窗函数
            ctx.strokeStyle = '#9c27b0';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i <= 100; i++) {
                const n = (i / 100) * (N - 1);
                const x = 30 + n * scaleX;
                const w_n = calculateWindow(n, N, windowType, beta);
                const y = centerY - w_n * scaleY;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 标题
            ctx.fillStyle = '#9c27b0';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${getWindowName(windowType)}窗函数`, width/2, offsetY + 15);
        }
        
        function drawWindowedFilter(ctx, offsetX, offsetY, width, height, windowType, N, cutoff, beta) {
            const centerY = offsetY + height * 0.8;
            const scaleX = (width - 60) / Math.PI;
            const scaleY = height * 0.5;
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(30, centerY);
            ctx.lineTo(width - 30, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(30, offsetY + 20);
            ctx.lineTo(30, centerY);
            ctx.stroke();
            
            // 绘制设计的滤波器响应
            ctx.strokeStyle = '#2ecc71';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i <= 200; i++) {
                const omega = (i / 200) * Math.PI;
                const x = 30 + omega * scaleX;
                const magnitude = calculateWindowedResponse(omega, windowType, N, cutoff, beta);
                const y = centerY - magnitude * scaleY;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 标题
            ctx.fillStyle = '#2ecc71';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('窗函数法设计结果', width/2, offsetY + 15);
            
            // 性能指标
            const performance = analyzeWindowPerformance(windowType, N);
            ctx.fillStyle = '#333';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`过渡带宽度: ${performance.transitionWidth}`, 40, offsetY + height - 30);
            ctx.fillText(`阻带衰减: ${performance.stopbandAtten}`, 40, offsetY + height - 15);
        }
        
        function calculateWindow(n, N, type, beta) {
            switch (type) {
                case 'rectangular':
                    return 1;
                case 'hanning':
                    return 0.5 * (1 - Math.cos(2 * Math.PI * n / (N - 1)));
                case 'hamming':
                    return 0.54 - 0.46 * Math.cos(2 * Math.PI * n / (N - 1));
                case 'blackman':
                    return 0.42 - 0.5 * Math.cos(2 * Math.PI * n / (N - 1)) + 0.08 * Math.cos(4 * Math.PI * n / (N - 1));
                case 'kaiser':
                    const alpha = (N - 1) / 2;
                    const arg = Math.sqrt(1 - Math.pow((n - alpha) / alpha, 2));
                    return modifiedBessel0(beta * arg) / modifiedBessel0(beta);
                default:
                    return 1;
            }
        }
        
        function modifiedBessel0(x) {
            // 修正贝塞尔函数的近似计算
            let sum = 1;
            let term = 1;
            for (let k = 1; k < 20; k++) {
                term *= (x / 2) / k;
                sum += term * term;
            }
            return sum;
        }
        
        function calculateWindowedResponse(omega, windowType, N, cutoff, beta) {
            // 简化的窗函数法滤波器响应计算
            let magnitude = 0;
            
            for (let n = 0; n < N; n++) {
                const shifted_n = n - (N - 1) / 2;
                let h_ideal;
                
                if (shifted_n === 0) {
                    h_ideal = cutoff / Math.PI;
                } else {
                    h_ideal = Math.sin(cutoff * Math.PI * shifted_n) / (Math.PI * shifted_n);
                }
                
                const window_val = calculateWindow(n, N, windowType, beta);
                const h_n = h_ideal * window_val;
                
                magnitude += h_n * Math.cos(omega * shifted_n);
            }
            
            return Math.abs(magnitude);
        }
        
        function getWindowName(type) {
            const names = {
                'rectangular': '矩形',
                'hanning': '汉宁',
                'hamming': '海明',
                'blackman': '布拉克曼',
                'kaiser': '凯泽'
            };
            return names[type] || type;
        }
        
        function analyzeWindowPerformance(windowType, N) {
            const performance = {
                'rectangular': { transitionWidth: `${(4 * Math.PI / N).toFixed(2)}π/${N}`, stopbandAtten: '-13dB' },
                'hanning': { transitionWidth: `${(8 * Math.PI / N).toFixed(2)}π/${N}`, stopbandAtten: '-31dB' },
                'hamming': { transitionWidth: `${(8 * Math.PI / N).toFixed(2)}π/${N}`, stopbandAtten: '-41dB' },
                'blackman': { transitionWidth: `${(12 * Math.PI / N).toFixed(2)}π/${N}`, stopbandAtten: '-57dB' },
                'kaiser': { transitionWidth: '可调', stopbandAtten: '可调' }
            };
            
            return performance[windowType] || { transitionWidth: '未知', stopbandAtten: '未知' };
        }
        
        // 更新频率抽样法演示
        function updateFrequencySampling() {
            const canvas = document.getElementById('frequencySamplingDemo');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            const N = parseInt(document.getElementById('samplingLength').value);
            const passband = parseFloat(document.getElementById('passband').value);
            const stopband = parseFloat(document.getElementById('stopband').value);
            const optimization = document.getElementById('transitionOpt').value;
            
            document.getElementById('samplingLengthValue').textContent = N;
            document.getElementById('passbandValue').textContent = passband.toFixed(2);
            document.getElementById('stopbandValue').textContent = stopband.toFixed(2);
            
            ctx.clearRect(0, 0, width, height);
            
            drawFrequencySamplingDemo(ctx, width, height, N, passband, stopband, optimization);
        }
        
        function drawFrequencySamplingDemo(ctx, width, height, N, passband, stopband, optimization) {
            const subHeight = height / 3;
            
            // 上：频率抽样点
            drawSamplingPoints(ctx, 0, 0, width, subHeight, N, passband, stopband, optimization);
            
            // 中：冲激响应
            drawSampledImpulseResponse(ctx, 0, subHeight, width, subHeight, N, passband, stopband, optimization);
            
            // 下：频率响应
            drawSampledFrequencyResponse(ctx, 0, 2*subHeight, width, subHeight, N, passband, stopband, optimization);
        }
        
        function drawSamplingPoints(ctx, offsetX, offsetY, width, height, N, passband, stopband, optimization) {
            const centerY = offsetY + height * 0.8;
            const scaleX = (width - 60) / Math.PI;
            const scaleY = height * 0.5;
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(30, centerY);
            ctx.lineTo(width - 30, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(30, offsetY + 20);
            ctx.lineTo(30, centerY);
            ctx.stroke();
            
            // 绘制抽样点
            for (let k = 0; k < N; k++) {
                const omega_k = 2 * Math.PI * k / N;
                if (omega_k <= Math.PI) {  // 只绘制[0, π]范围
                    const x = 30 + omega_k * scaleX;
                    let H_k = getSampledValue(omega_k, passband, stopband, optimization);
                    const y = centerY - H_k * scaleY;
                    
                    // 抽样点
                    ctx.fillStyle = '#2196f3';
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // 标注
                    ctx.fillStyle = '#333';
                    ctx.font = '8px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`H[${k}]`, x, y - 10);
                }
            }
            
            // 理想响应曲线
            ctx.strokeStyle = '#e74c3c';
            ctx.setLineDash([3, 3]);
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i <= 100; i++) {
                const omega = (i / 100) * Math.PI;
                const x = 30 + omega * scaleX;
                let ideal_response;
                
                if (omega <= passband * Math.PI) {
                    ideal_response = 1;
                } else if (omega >= stopband * Math.PI) {
                    ideal_response = 0;
                } else {
                    ideal_response = 0.5; // 过渡带
                }
                
                const y = centerY - ideal_response * scaleY;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            ctx.setLineDash([]);
            
            // 标题
            ctx.fillStyle = '#2196f3';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`频率抽样点 (N=${N})`, width/2, offsetY + 15);
        }
        
        function drawSampledImpulseResponse(ctx, offsetX, offsetY, width, height, N, passband, stopband, optimization) {
            const centerY = offsetY + height * 0.8;
            const scaleX = (width - 60) / N;
            const scaleY = height * 0.4;
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(30, centerY);
            ctx.lineTo(width - 30, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(30, offsetY + 20);
            ctx.lineTo(30, centerY);
            ctx.stroke();
            
            // 计算并绘制冲激响应
            ctx.strokeStyle = '#ff9800';
            ctx.lineWidth = 2;
            ctx.fillStyle = '#ff9800';
            
            for (let n = 0; n < N; n++) {
                const x = 30 + n * scaleX + scaleX/2;
                const h_n = calculateSampledImpulseResponse(n, N, passband, stopband, optimization);
                const y = centerY - h_n * scaleY;
                
                // 绘制冲激
                ctx.beginPath();
                ctx.moveTo(x, centerY);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                // 绘制冲激顶点
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // 标题
            ctx.fillStyle = '#ff9800';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('设计的冲激响应 h[n]', width/2, offsetY + 15);
        }
        
        function drawSampledFrequencyResponse(ctx, offsetX, offsetY, width, height, N, passband, stopband, optimization) {
            const centerY = offsetY + height * 0.8;
            const scaleX = (width - 60) / Math.PI;
            const scaleY = height * 0.5;
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(30, centerY);
            ctx.lineTo(width - 30, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(30, offsetY + 20);
            ctx.lineTo(30, centerY);
            ctx.stroke();
            
            // 绘制频率响应
            ctx.strokeStyle = '#4caf50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i <= 200; i++) {
                const omega = (i / 200) * Math.PI;
                const x = 30 + omega * scaleX;
                const magnitude = calculateSampledFrequencyResponse(omega, N, passband, stopband, optimization);
                const y = centerY - magnitude * scaleY;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 标题
            ctx.fillStyle = '#4caf50';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`频率抽样法设计结果 (${optimization === 'optimized' ? '过渡带优化' : '简单方法'})`, width/2, offsetY + 15);
        }
        
        function getSampledValue(omega, passband, stopband, optimization) {
            if (omega <= passband * Math.PI) {
                return 1;
            } else if (omega >= stopband * Math.PI) {
                return 0;
            } else {
                // 过渡带
                if (optimization === 'optimized') {
                    // 简化的优化值
                    const ratio = (omega - passband * Math.PI) / ((stopband - passband) * Math.PI);
                    return 0.7 * (1 - ratio);  // 优化后的过渡带值
                } else {
                    return 0.5;  // 简单方法
                }
            }
        }
        
        function calculateSampledImpulseResponse(n, N, passband, stopband, optimization) {
            // 使用IDFT计算冲激响应
            let h_n = 0;
            
            for (let k = 0; k < N; k++) {
                const omega_k = 2 * Math.PI * k / N;
                const H_k = getSampledValue(omega_k, passband, stopband, optimization);
                h_n += H_k * Math.cos(2 * Math.PI * k * n / N) / N;
            }
            
            return h_n;
        }
        
        function calculateSampledFrequencyResponse(omega, N, passband, stopband, optimization) {
            // 计算频率响应
            let magnitude = 0;
            
            for (let n = 0; n < N; n++) {
                const h_n = calculateSampledImpulseResponse(n, N, passband, stopband, optimization);
                magnitude += h_n * Math.cos(omega * n);
            }
            
            return Math.abs(magnitude);
        }
        
        // 更新IIR vs FIR对比演示
        function updateComparison() {
            const canvas = document.getElementById('iirVsFirDemo');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            const filterSpec = document.getElementById('filterSpec').value;
            const ripple = parseFloat(document.getElementById('ripple').value);
            const stopAtten = parseFloat(document.getElementById('stopAtten').value);
            
            document.getElementById('rippleValue').textContent = ripple;
            document.getElementById('stopAttenValue').textContent = stopAtten;
            
            ctx.clearRect(0, 0, width, height);
            
            drawIIRvsFIRComparison(ctx, width, height, filterSpec, ripple, stopAtten);
            updateComparisonResults(filterSpec, ripple, stopAtten);
        }
        
        function drawIIRvsFIRComparison(ctx, width, height, filterSpec, ripple, stopAtten) {
            const subHeight = height / 2;
            
            // 上半部分：IIR滤波器
            drawFilterComparison(ctx, 0, 0, width, subHeight, 'IIR', filterSpec, ripple, stopAtten);
            
            // 下半部分：FIR滤波器
            drawFilterComparison(ctx, 0, subHeight, width, subHeight, 'FIR', filterSpec, ripple, stopAtten);
        }
        
        function drawFilterComparison(ctx, offsetX, offsetY, width, height, type, filterSpec, ripple, stopAtten) {
            const centerY = offsetY + height * 0.8;
            const scaleX = (width - 60) / Math.PI;
            const scaleY = height * 0.5;
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(30, centerY);
            ctx.lineTo(width - 30, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(30, offsetY + 20);
            ctx.lineTo(30, centerY);
            ctx.stroke();
            
            // 绘制频率响应
            const color = type === 'IIR' ? '#e74c3c' : '#2ecc71';
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i <= 200; i++) {
                const omega = (i / 200) * Math.PI;
                const x = 30 + omega * scaleX;
                const magnitude = calculateFilterResponse(omega, type, filterSpec, ripple, stopAtten);
                const y = centerY - magnitude * scaleY;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 标题
            ctx.fillStyle = color;
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${type}${filterSpec === 'lowpass' ? '低通' : '带通'}滤波器`, width/2, offsetY + 15);
            
            // 指标线
            drawSpecificationLines(ctx, offsetX, offsetY, width, height, scaleX, scaleY, centerY, filterSpec, ripple, stopAtten);
        }
        
        function drawSpecificationLines(ctx, offsetX, offsetY, width, height, scaleX, scaleY, centerY, filterSpec, ripple, stopAtten) {
            ctx.strokeStyle = '#666';
            ctx.setLineDash([3, 3]);
            ctx.lineWidth = 1;
            
            if (filterSpec === 'lowpass') {
                // 通带纹波线
                const rippleLinear = 1 - ripple * 0.1;  // 简化转换
                ctx.beginPath();
                ctx.moveTo(30, centerY - rippleLinear * scaleY);
                ctx.lineTo(30 + 0.3 * Math.PI * scaleX, centerY - rippleLinear * scaleY);
                ctx.stroke();
                
                // 阻带衰减线
                const stopLinear = Math.pow(10, -stopAtten / 20);
                ctx.beginPath();
                ctx.moveTo(30 + 0.5 * Math.PI * scaleX, centerY - stopLinear * scaleY);
                ctx.lineTo(width - 30, centerY - stopLinear * scaleY);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
        }
        
        function calculateFilterResponse(omega, type, filterSpec, ripple, stopAtten) {
            // 简化的滤波器响应计算
            let magnitude = 1;
            
            if (filterSpec === 'lowpass') {
                if (type === 'IIR') {
                    // IIR低通：陡峭过渡
                    const order = Math.ceil(stopAtten / 6);  // 简化的阶数估计
                    magnitude = 1 / Math.sqrt(1 + Math.pow(omega / (0.4 * Math.PI), 2 * order));
                    
                    // 添加通带纹波
                    if (omega <= 0.3 * Math.PI) {
                        magnitude *= (1 + 0.1 * ripple * Math.sin(omega * 20));
                    }
                } else {
                    // FIR低通：较缓过渡
                    const N = Math.ceil(stopAtten * 0.5);  // 简化的长度估计
                    if (omega <= 0.3 * Math.PI) {
                        magnitude = 1;
                    } else if (omega >= 0.5 * Math.PI) {
                        magnitude = Math.pow(10, -stopAtten / 20);
                    } else {
                        // 过渡带
                        const ratio = (omega - 0.3 * Math.PI) / (0.2 * Math.PI);
                        magnitude = (1 - ratio) + ratio * Math.pow(10, -stopAtten / 20);
                    }
                    
                    // FIR的纹波特性
                    magnitude += 0.02 * Math.sin(omega * N);
                }
            }
            
            return Math.max(0.001, Math.min(1.2, magnitude));
        }
        
        function updateComparisonResults(filterSpec, ripple, stopAtten) {
            const resultDiv = document.getElementById('comparisonResults');
            
            // 简化的设计估算
            const iirOrder = Math.ceil(stopAtten / 6);
            const firLength = Math.ceil(stopAtten * 0.8);
            
            const iirMultipliers = iirOrder * 2;  // 分子分母系数
            const firMultipliers = firLength;
            
            const iirMemory = iirOrder * 2;
            const firMemory = firLength;
            
            resultDiv.innerHTML = `
                <h4>设计对比结果</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <h5 style="color: #e74c3c;">IIR滤波器</h5>
                        <ul>
                            <li><strong>阶数：</strong>${iirOrder}</li>
                            <li><strong>乘法器数量：</strong>${iirMultipliers}</li>
                            <li><strong>存储单元：</strong>${iirMemory}</li>
                            <li><strong>相位特性：</strong>非线性</li>
                            <li><strong>稳定性：</strong>需要检查</li>
                        </ul>
                    </div>
                    <div>
                        <h5 style="color: #2ecc71;">FIR滤波器</h5>
                        <ul>
                            <li><strong>长度：</strong>${firLength}</li>
                            <li><strong>乘法器数量：</strong>${firMultipliers}</li>
                            <li><strong>存储单元：</strong>${firMemory}</li>
                            <li><strong>相位特性：</strong>严格线性</li>
                            <li><strong>稳定性：</strong>总是稳定</li>
                        </ul>
                    </div>
                </div>
                <p><strong>计算复杂度比：</strong>IIR:FIR = 1:${(firMultipliers/iirMultipliers).toFixed(1)}</p>
                <p><strong>推荐选择：</strong>${iirMultipliers < firMultipliers ? 'IIR滤波器（计算效率优势）' : 'FIR滤波器（线性相位优势）'}</p>
            `;
        }
        
        // 切换答案显示
        function toggleAnswer(answerId) {
            const answer = document.getElementById(answerId);
            answer.style.display = answer.style.display === 'none' ? 'block' : 'none';
        }
        
        // 页面加载后初始化
        window.onload = function() {
            updateLinearPhase();
            updateWindowMethod();
            updateFrequencySampling();
            updateComparison();
        };
    </script>
</body>
</html>
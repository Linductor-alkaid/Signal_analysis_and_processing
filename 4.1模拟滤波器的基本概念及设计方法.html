<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>模拟滤波器基本概念</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 30px;
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }
        
        h2 {
            color: #34495e;
            border-left: 4px solid #3498db;
            padding-left: 15px;
            margin-top: 30px;
        }
        
        h3 {
            color: #2980b9;
            margin-top: 25px;
        }
        
        .knowledge-point {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }
        
        .formula {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            font-family: 'Times New Roman', serif;
            font-size: 18px;
        }
        
        .important {
            background: #ffeaa7;
            border: 2px solid #fdcb6e;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .example {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .plot-container {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }
        
        canvas {
            border: 1px solid #ccc;
            margin: 10px;
        }
        
        .controls {
            margin: 15px 0;
            text-align: center;
        }
        
        .controls input, .controls select {
            margin: 5px;
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .controls button {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        
        .controls button:hover {
            background: #2980b9;
        }
        
        .exercise {
            background: #e8f5e8;
            border: 1px solid #c3e6c3;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .exercise h4 {
            color: #2e7d2e;
            margin-top: 0;
        }
        
        .answer {
            background: #f0f0f0;
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
            display: none;
        }
        
        .show-answer {
            background: #28a745;
            color: white;
            border: none;
            padding: 5px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        
        .show-answer:hover {
            background: #218838;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        th {
            background: #f2f2f2;
        }
        
        .highlight {
            background: #ffeb3b;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .concept-box {
            background: #e3f2fd;
            border: 2px solid #2196f3;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }
        
        .filter-types {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        
        .filter-type {
            background: #f0f8ff;
            border: 1px solid #87ceeb;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }
        
        .design-flow {
            background: #fff3e0;
            border: 1px solid #ffb74d;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .design-step {
            background: #e8f5e8;
            border: 1px solid #4caf50;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            text-align: center;
        }
        
        .characteristic-comparison {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }
        
        .characteristic-part {
            text-align: center;
            flex: 1;
            margin: 0 10px;
        }
        
        .distortion-demo {
            background: #ffeee8;
            border: 1px solid #ff9800;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .transition-box {
            background: #f3e5f5;
            border: 2px solid #9c27b0;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>模拟滤波器基本概念</h1>
        
        <div class="transition-box">
            <h3>🔄 知识转换：从数字到模拟</h3>
            <p>前七章我们学习了<strong>离散时间信号处理</strong>，现在转向<strong>连续时间(模拟)滤波器</strong>设计。两者的关系：</p>
            <ul>
                <li><strong>理论基础</strong>：傅里叶变换理论是共同基础</li>
                <li><strong>设计思想</strong>：频域分析和滤波概念相通</li>
                <li><strong>实现方式</strong>：模拟→电路实现，数字→算法实现</li>
                <li><strong>应用互补</strong>：模拟滤波器常作为数字系统的前端处理</li>
            </ul>
        </div>
        
        <h2>模拟滤波器的基本概念</h2>
        
        <div class="concept-box">
            <h3>📍 滤波器的定义</h3>
            <p><strong>滤波器</strong>是一种能够<span class="highlight">有选择地传输不同频率成分</span>的线性时不变系统。</p>
            <div class="formula">
                y(t) = h(t) * x(t) ↔ Y(jω) = H(jω) · X(jω)
            </div>
            <p>其中H(jω)称为<strong>频率响应</strong>或<strong>传递函数</strong>，决定了滤波器的频率选择特性。</p>
        </div>
        
        <div class="knowledge-point">
            <h3>滤波器的基本功能</h3>
            <ol>
                <li><strong>频率选择</strong>：允许某些频率通过，抑制另一些频率</li>
                <li><strong>信号分离</strong>：从复合信号中提取所需的频率成分</li>
                <li><strong>噪声抑制</strong>：滤除不需要的噪声和干扰</li>
                <li><strong>频谱整形</strong>：改变信号的频谱特性</li>
                <li><strong>信号调理</strong>：为后续处理准备合适的信号形式</li>
            </ol>
        </div>
        
        <div class="filter-types">
            <div class="filter-type">
                <h4>低通滤波器</h4>
                <p><strong>Low-Pass Filter</strong></p>
                <p>通过低频，抑制高频</p>
                <p>应用：抗混叠、平滑</p>
            </div>
            <div class="filter-type">
                <h4>高通滤波器</h4>
                <p><strong>High-Pass Filter</strong></p>
                <p>通过高频，抑制低频</p>
                <p>应用：去除直流、边缘检测</p>
            </div>
            <div class="filter-type">
                <h4>带通滤波器</h4>
                <p><strong>Band-Pass Filter</strong></p>
                <p>通过某频段，抑制其他</p>
                <p>应用：信道选择、调制解调</p>
            </div>
            <div class="filter-type">
                <h4>带阻滤波器</h4>
                <p><strong>Band-Stop Filter</strong></p>
                <p>抑制某频段，通过其他</p>
                <p>应用：工频干扰抑制</p>
            </div>
        </div>
        
        <div class="plot-container">
            <h3>四种基本滤波器类型演示</h3>
            <canvas id="filterTypesDemo" width="800" height="400"></canvas>
            <div class="controls">
                <label>滤波器类型：</label>
                <select id="filterTypeSelect">
                    <option value="lowpass">低通滤波器</option>
                    <option value="highpass">高通滤波器</option>
                    <option value="bandpass">带通滤波器</option>
                    <option value="bandstop">带阻滤波器</option>
                </select>
                <label>截止频率：</label>
                <input type="range" id="cutoffFreq" min="0.1" max="10" step="0.1" value="2">
                <span id="cutoffValue">2.0</span> Hz
                <button onclick="updateFilterDemo()">更新滤波器</button>
            </div>
        </div>
        
        <h2>无失真传输</h2>
        
        <div class="knowledge-point">
            <h3>无失真传输的定义</h3>
            <p>如果系统的输出信号只是输入信号的<strong>幅度缩放</strong>和<strong>时间延迟</strong>，则称为无失真传输：</p>
            <div class="formula">
                y(t) = K · x(t - τ)
            </div>
            <p>其中：K为增益常数，τ为时间延迟</p>
        </div>
        
        <div class="important">
            <h3>⚡ 无失真传输的条件</h3>
            <p>系统实现无失真传输必须满足：</p>
            
            <h4>1. 幅度条件</h4>
            <div class="formula">
                |H(jω)| = K = 常数 （在所有频率上）
            </div>
            
            <h4>2. 相位条件</h4>
            <div class="formula">
                ∠H(jω) = -ωτ （相位与频率成线性关系）
            </div>
            
            <h4>3. 群延迟条件</h4>
            <div class="formula">
                τ_g(ω) = -d∠H(jω)/dω = τ = 常数
            </div>
        </div>
        
        <div class="distortion-demo">
            <h3>🔍 失真类型分析</h3>
            <div class="comparison-grid">
                <div class="comparison-item">
                    <h4>幅度失真</h4>
                    <p>|H(jω)| ≠ 常数</p>
                    <p><strong>后果：</strong>不同频率成分被不同程度地放大或衰减</p>
                    <p><strong>表现：</strong>波形形状改变</p>
                </div>
                <div class="comparison-item">
                    <h4>相位失真</h4>
                    <p>∠H(jω) ≠ -ωτ</p>
                    <p><strong>后果：</strong>不同频率成分的时间关系改变</p>
                    <p><strong>表现：</strong>波形时间结构变化</p>
                </div>
            </div>
        </div>
        
        <div class="plot-container">
            <h3>无失真传输与失真传输对比</h3>
            <div class="characteristic-comparison">
                <div class="characteristic-part">
                    <canvas id="inputSignal" width="250" height="200"></canvas>
                    <p>输入信号</p>
                </div>
                <div class="characteristic-part">
                    <canvas id="undistortedOutput" width="250" height="200"></canvas>
                    <p>无失真输出</p>
                </div>
                <div class="characteristic-part">
                    <canvas id="distortedOutput" width="250" height="200"></canvas>
                    <p>有失真输出</p>
                </div>
            </div>
            <div class="controls">
                <label>输入信号：</label>
                <select id="inputSignalType">
                    <option value="square">方波</option>
                    <option value="triangle">三角波</option>
                    <option value="pulse">脉冲</option>
                    <option value="chirp">线性调频</option>
                </select>
                <label>失真类型：</label>
                <select id="distortionType">
                    <option value="amplitude">幅度失真</option>
                    <option value="phase">相位失真</option>
                    <option value="both">幅度+相位失真</option>
                </select>
                <button onclick="demonstrateDistortion()">演示失真效果</button>
            </div>
        </div>
        
        <h2>滤波器的理想特性与实际特性</h2>
        
        <div class="knowledge-point">
            <h3>理想滤波器特性</h3>
            <p>理想滤波器具有<strong>矩形频率响应</strong>：</p>
            
            <h4>理想低通滤波器</h4>
            <div class="formula">
                H(jω) = {1, |ω| ≤ ω_c; 0, |ω| > ω_c}
            </div>
            
            <div class="example">
                <h4>理想滤波器的特点</h4>
                <ul>
                    <li><strong>通带</strong>：完全无损传输（|H(jω)| = 1）</li>
                    <li><strong>阻带</strong>：完全阻断传输（|H(jω)| = 0）</li>
                    <li><strong>过渡带</strong>：瞬间过渡（宽度为0）</li>
                    <li><strong>相位</strong>：线性相位特性</li>
                </ul>
            </div>
        </div>
        
        <div class="important">
            <h3>⚠️ 理想滤波器的问题</h3>
            <ul>
                <li><strong>非因果性</strong>：冲激响应在t<0时不为零</li>
                <li><strong>无限长</strong>：冲激响应为sinc函数，时域无限长</li>
                <li><strong>物理不可实现</strong>：需要无限多的元件</li>
                <li><strong>吉布斯现象</strong>：阶跃响应有振荡和过冲</li>
            </ul>
        </div>
        
        <div class="knowledge-point">
            <h3>实际滤波器特性</h3>
            <p>实际滤波器必须在理想特性和可实现性之间折衷：</p>
            
            <div class="comparison-grid">
                <div class="comparison-item">
                    <h4>理想滤波器</h4>
                    <ul>
                        <li>矩形频率响应</li>
                        <li>无过渡带</li>
                        <li>完美的通带和阻带</li>
                        <li>线性相位</li>
                        <li><strong>物理不可实现</strong></li>
                    </ul>
                </div>
                <div class="comparison-item">
                    <h4>实际滤波器</h4>
                    <ul>
                        <li>平滑的频率响应</li>
                        <li>有限的过渡带</li>
                        <li>通带纹波，阻带泄漏</li>
                        <li>非线性相位</li>
                        <li><strong>物理可实现</strong></li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="plot-container">
            <h3>理想特性 vs 实际特性对比</h3>
            <canvas id="idealVsReal" width="800" height="400"></canvas>
            <div class="controls">
                <label>滤波器阶数：</label>
                <input type="range" id="filterOrder" min="1" max="8" step="1" value="4">
                <span id="orderValue">4</span>
                <label>滤波器类型：</label>
                <select id="realizationMethod">
                    <option value="butterworth">巴特沃斯</option>
                    <option value="chebyshev">切比雪夫</option>
                    <option value="elliptic">椭圆</option>
                </select>
                <button onclick="compareIdealReal()">对比特性</button>
            </div>
        </div>
        
        <h2>模拟滤波器的一般设计方法</h2>
        
        <div class="design-flow">
            <h3>🔧 滤波器设计的一般流程</h3>
            
            <div class="design-step">
                <h4>步骤1：需求分析</h4>
                <p>确定技术指标：通带、阻带、纹波、衰减等</p>
            </div>
            
            <div class="design-step">
                <h4>步骤2：逼近方法选择</h4>
                <p>选择合适的逼近函数：巴特沃斯、切比雪夫、椭圆等</p>
            </div>
            
            <div class="design-step">
                <h4>步骤3：传递函数设计</h4>
                <p>确定滤波器的s域传递函数H(s)</p>
            </div>
            
            <div class="design-step">
                <h4>步骤4：电路实现</h4>
                <p>选择实现结构：无源、有源、开关电容等</p>
            </div>
            
            <div class="design-step">
                <h4>步骤5：仿真验证</h4>
                <p>验证设计是否满足技术指标要求</p>
            </div>
        </div>
        
        <div class="knowledge-point">
            <h3>设计技术指标</h3>
            <p>模拟滤波器设计通常需要指定以下技术参数：</p>
            
            <table>
                <tr>
                    <th>参数</th>
                    <th>符号</th>
                    <th>定义</th>
                    <th>典型值</th>
                </tr>
                <tr>
                    <td>通带截止频率</td>
                    <td>f_p, ω_p</td>
                    <td>通带边界频率</td>
                    <td>根据应用确定</td>
                </tr>
                <tr>
                    <td>阻带截止频率</td>
                    <td>f_s, ω_s</td>
                    <td>阻带开始频率</td>
                    <td>根据应用确定</td>
                </tr>
                <tr>
                    <td>通带纹波</td>
                    <td>R_p</td>
                    <td>通带内幅度变化</td>
                    <td>0.1~3 dB</td>
                </tr>
                <tr>
                    <td>阻带衰减</td>
                    <td>A_s</td>
                    <td>阻带最小衰减</td>
                    <td>20~80 dB</td>
                </tr>
                <tr>
                    <td>过渡带宽</td>
                    <td>Δω</td>
                    <td>ω_s - ω_p</td>
                    <td>越小越好</td>
                </tr>
            </table>
        </div>
        
        <div class="important">
            <h3>🎯 设计中的权衡考虑</h3>
            <div class="comparison-grid">
                <div class="comparison-item">
                    <h4>性能要求</h4>
                    <ul>
                        <li>频率选择性能</li>
                        <li>相位线性度</li>
                        <li>时域响应</li>
                        <li>稳定性</li>
                    </ul>
                </div>
                <div class="comparison-item">
                    <h4>实现约束</h4>
                    <ul>
                        <li>元件容差</li>
                        <li>成本限制</li>
                        <li>功耗要求</li>
                        <li>体积限制</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="plot-container">
            <h3>滤波器设计参数可视化</h3>
            <canvas id="designParameters" width="800" height="400"></canvas>
            <div class="controls">
                <label>通带截止频率：</label>
                <input type="range" id="passbandFreq" min="0.5" max="5" step="0.1" value="2">
                <span id="passbandValue">2.0</span> Hz
                <label>阻带截止频率：</label>
                <input type="range" id="stopbandFreq" min="2" max="10" step="0.1" value="4">
                <span id="stopbandValue">4.0</span> Hz
                <label>通带纹波：</label>
                <input type="range" id="passbandRipple" min="0.1" max="3" step="0.1" value="1">
                <span id="rippleValue">1.0</span> dB
                <label>阻带衰减：</label>
                <input type="range" id="stopbandAtten" min="20" max="80" step="5" value="40">
                <span id="attenValue">40</span> dB
                <button onclick="updateDesignParameters()">更新参数</button>
            </div>
        </div>
        
        <h2>练习题目</h2>
        
        <div class="exercise">
            <h4>练习1：滤波器类型识别</h4>
            <p>根据以下应用场景，选择最合适的滤波器类型：</p>
            <ol>
                <li>从含有高频噪声的音频信号中提取有用信号</li>
                <li>去除信号中的直流分量</li>
                <li>从复合信号中提取特定频段的调制信号</li>
                <li>抑制50Hz工频干扰</li>
            </ol>
            <button class="show-answer" onclick="toggleAnswer('answer1')">显示答案</button>
            <div id="answer1" class="answer">
                <strong>答案：</strong><br>
                1. 低通滤波器 - 保留低频有用信号，滤除高频噪声<br>
                2. 高通滤波器 - 阻断直流（0Hz），保留交流成分<br>
                3. 带通滤波器 - 只保留特定频段的信号<br>
                4. 带阻滤波器（陷波器）- 专门抑制50Hz频率成分
            </div>
        </div>
        
        <div class="exercise">
            <h4>练习2：无失真传输条件</h4>
            <p>系统的传递函数为 H(jω) = 2e^(-j3ω)，判断：</p>
            <ol>
                <li>该系统是否满足无失真传输条件？</li>
                <li>如果满足，求出增益K和延迟τ</li>
                <li>写出输出与输入的关系</li>
            </ol>
            <button class="show-answer" onclick="toggleAnswer('answer2')">显示答案</button>
            <div id="answer2" class="answer">
                <strong>答案：</strong><br>
                1. 满足无失真传输条件<br>
                2. |H(jω)| = 2 = K（常数），∠H(jω) = -3ω = -ωτ，所以K = 2，τ = 3<br>
                3. y(t) = 2x(t - 3)，输出是输入信号放大2倍并延迟3个时间单位
            </div>
        </div>
        
        <div class="exercise">
            <h4>练习3：失真类型分析</h4>
            <p>某系统对正弦信号的响应如下：</p>
            <p>输入：x(t) = cos(ω₁t) + cos(ω₂t)</p>
            <p>输出：y(t) = 2cos(ω₁t - π/4) + cos(ω₂t - π/2)</p>
            <p>分析该系统存在什么类型的失真？</p>
            <button class="show-answer" onclick="toggleAnswer('answer3')">显示答案</button>
            <div id="answer3" class="answer">
                <strong>答案：</strong><br>
                存在幅度失真和相位失真：<br>
                1. 幅度失真：ω₁频率成分被放大2倍，ω₂频率成分保持不变<br>
                2. 相位失真：两个频率成分的相位延迟不同（π/4 vs π/2），不满足线性相位条件<br>
                因此该系统既有幅度失真又有相位失真
            </div>
        </div>
        
        <div class="exercise">
            <h4>练习4：设计指标分析</h4>
            <p>某低通滤波器设计要求：</p>
            <ul>
                <li>通带截止频率：1kHz</li>
                <li>阻带截止频率：2kHz</li>
                <li>通带纹波：≤1dB</li>
                <li>阻带衰减：≥40dB</li>
            </ul>
            <p>分析这些指标的合理性，并说明过渡带宽度对滤波器阶数的影响。</p>
            <button class="show-answer" onclick="toggleAnswer('answer4')">显示答案</button>
            <div id="answer4" class="answer">
                <strong>答案：</strong><br>
                1. 指标合理性：通带和阻带频率比为2:1，过渡带相对较宽，指标要求中等，合理<br>
                2. 过渡带宽度 = 2kHz - 1kHz = 1kHz<br>
                3. 过渡带越窄，所需滤波器阶数越高：<br>
                   - 宽过渡带：可用低阶滤波器实现，简单经济<br>
                   - 窄过渡带：需要高阶滤波器，复杂昂贵<br>
                4. 该指标下估计需要4-6阶滤波器可以满足要求
            </div>
        </div>
        
        <h2>8.1.5 学习要点总结</h2>
        
        <div class="important">
            <h3>🎯 本节核心要点</h3>
            <ol>
                <li><strong>滤波器概念</strong>：频率选择性线性时不变系统</li>
                <li><strong>四种基本类型</strong>：低通、高通、带通、带阻</li>
                <li><strong>无失真传输</strong>：幅度为常数，相位线性，群延迟恒定</li>
                <li><strong>理想vs实际</strong>：理想不可实现，实际需要折衷</li>
                <li><strong>设计流程</strong>：需求→逼近→传递函数→电路→验证</li>
                <li><strong>技术指标</strong>：通带、阻带、纹波、衰减、过渡带</li>
            </ol>
        </div>
        
        <div class="concept-box">
            <h3>🔗 与数字滤波器的联系</h3>
            <p><strong>相同点：</strong></p>
            <ul>
                <li>都基于频域分析和滤波概念</li>
                <li>都有相同的滤波器分类</li>
                <li>设计指标和性能要求类似</li>
            </ul>
            <p><strong>不同点：</strong></p>
            <ul>
                <li>数学工具：连续傅里叶变换 vs 离散傅里叶变换</li>
                <li>实现方式：模拟电路 vs 数字算法</li>
                <li>设计方法：s域设计 vs z域设计</li>
            </ul>
        </div>
    </div>

    <script>
        // 绘制四种滤波器类型演示
        function updateFilterDemo() {
            const canvas = document.getElementById('filterTypesDemo');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const filterType = document.getElementById('filterTypeSelect').value;
            const cutoff = parseFloat(document.getElementById('cutoffFreq').value);
            
            document.getElementById('cutoffValue').textContent = cutoff.toFixed(1);
            
            ctx.clearRect(0, 0, width, height);
            
            // 绘制四个子图
            const subWidth = width / 2;
            const subHeight = height / 2;
            
            drawFilterResponse(ctx, 0, 0, subWidth, subHeight, 'lowpass', cutoff, '低通滤波器');
            drawFilterResponse(ctx, subWidth, 0, subWidth, subHeight, 'highpass', cutoff, '高通滤波器');
            drawFilterResponse(ctx, 0, subHeight, subWidth, subHeight, 'bandpass', cutoff, '带通滤波器');
            drawFilterResponse(ctx, subWidth, subHeight, subWidth, subHeight, 'bandstop', cutoff, '带阻滤波器');
            
            // 高亮当前选择的类型
            highlightSelectedFilter(ctx, filterType, subWidth, subHeight);
        }
        
        function drawFilterResponse(ctx, offsetX, offsetY, subWidth, subHeight, type, cutoff, title) {
            const centerY = offsetY + subHeight * 0.8;
            const freqRange = 10; // 0 to 10 Hz
            const scaleX = (subWidth - 40) / freqRange;
            const scaleY = subHeight * 0.5;
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            // x轴
            ctx.beginPath();
            ctx.moveTo(offsetX + 20, centerY);
            ctx.lineTo(offsetX + subWidth - 20, centerY);
            ctx.stroke();
            
            // y轴
            ctx.beginPath();
            ctx.moveTo(offsetX + 20, offsetY + 20);
            ctx.lineTo(offsetX + 20, centerY);
            ctx.stroke();
            
            // 绘制频率响应
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const points = 200;
            for (let i = 0; i <= points; i++) {
                const freq = (i / points) * freqRange;
                const x = offsetX + 20 + freq * scaleX;
                let magnitude = 0;
                
                switch (type) {
                    case 'lowpass':
                        magnitude = freq <= cutoff ? 1 : 0.01;
                        break;
                    case 'highpass':
                        magnitude = freq >= cutoff ? 1 : 0.01;
                        break;
                    case 'bandpass':
                        magnitude = (freq >= cutoff * 0.8 && freq <= cutoff * 1.2) ? 1 : 0.01;
                        break;
                    case 'bandstop':
                        magnitude = (freq >= cutoff * 0.8 && freq <= cutoff * 1.2) ? 0.01 : 1;
                        break;
                }
                
                const y = centerY - magnitude * scaleY;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 标题
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(title, offsetX + subWidth / 2, offsetY + 15);
            
            // 频率轴标签
            ctx.font = '10px Arial';
            ctx.fillText('0', offsetX + 20, centerY + 15);
            ctx.fillText('5', offsetX + 20 + 5 * scaleX, centerY + 15);
            ctx.fillText('10 Hz', offsetX + 20 + 10 * scaleX, centerY + 15);
            
            // 幅度轴标签
            ctx.textAlign = 'right';
            ctx.fillText('1', offsetX + 15, offsetY + 25);
            ctx.fillText('0', offsetX + 15, centerY + 5);
        }
        
        function highlightSelectedFilter(ctx, selectedType, subWidth, subHeight) {
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            
            let x = 0, y = 0;
            switch (selectedType) {
                case 'lowpass':
                    x = 0; y = 0;
                    break;
                case 'highpass':
                    x = subWidth; y = 0;
                    break;
                case 'bandpass':
                    x = 0; y = subHeight;
                    break;
                case 'bandstop':
                    x = subWidth; y = subHeight;
                    break;
            }
            
            ctx.beginPath();
            ctx.rect(x + 2, y + 2, subWidth - 4, subHeight - 4);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // 演示失真效果
        function demonstrateDistortion() {
            const signalType = document.getElementById('inputSignalType').value;
            const distortionType = document.getElementById('distortionType').value;
            
            // 生成输入信号
            const t = [];
            const input = [];
            const fs = 100; // 采样频率
            const duration = 2; // 信号长度
            
            for (let i = 0; i < fs * duration; i++) {
                const time = i / fs;
                t.push(time);
                
                let signal = 0;
                switch (signalType) {
                    case 'square':
                        signal = Math.sign(Math.sin(2 * Math.PI * 2 * time));
                        break;
                    case 'triangle':
                        signal = 2 * Math.abs((time * 2) % 2 - 1) - 1;
                        break;
                    case 'pulse':
                        signal = (time % 1 < 0.1) ? 1 : 0;
                        break;
                    case 'chirp':
                        signal = Math.sin(2 * Math.PI * time * (1 + time));
                        break;
                }
                input.push(signal);
            }
            
            // 生成无失真输出（延迟和增益）
            const undistorted = input.map(val => 0.8 * val); // 延迟在此简化处理
            
            // 生成有失真输出
            const distorted = [];
            for (let i = 0; i < input.length; i++) {
                let output = input[i];
                
                switch (distortionType) {
                    case 'amplitude':
                        // 幅度失真：高频衰减
                        output *= (1 - 0.3 * Math.abs(input[i]));
                        break;
                    case 'phase':
                        // 相位失真：简化的非线性相位
                        output = i > 0 ? 0.7 * input[i] + 0.3 * input[i-1] : input[i];
                        break;
                    case 'both':
                        // 幅度和相位失真
                        output *= (1 - 0.2 * Math.abs(input[i]));
                        output = i > 0 ? 0.6 * output + 0.4 * input[i-1] : output;
                        break;
                }
                distorted.push(output);
            }
            
            // 绘制信号
            plotTimeSignal(input, 'inputSignal', '输入信号');
            plotTimeSignal(undistorted, 'undistortedOutput', '无失真输出');
            plotTimeSignal(distorted, 'distortedOutput', '有失真输出');
        }
        
        function plotTimeSignal(signal, canvasId, title) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            const centerY = height / 2;
            const scaleX = (width - 40) / signal.length;
            const maxVal = Math.max(...signal.map(Math.abs));
            const scaleY = (height * 0.3) / maxVal;
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(20, centerY);
            ctx.lineTo(width - 20, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(20, 20);
            ctx.lineTo(20, height - 20);
            ctx.stroke();
            
            // 绘制信号
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            signal.forEach((val, index) => {
                const x = 20 + index * scaleX;
                const y = centerY - val * scaleY;
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // 标题
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(title, width / 2, 15);
        }
        
        // 对比理想与实际特性
        function compareIdealReal() {
            const canvas = document.getElementById('idealVsReal');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const order = parseInt(document.getElementById('filterOrder').value);
            const method = document.getElementById('realizationMethod').value;
            
            document.getElementById('orderValue').textContent = order;
            
            ctx.clearRect(0, 0, width, height);
            
            // 绘制理想和实际频率响应对比
            drawIdealVsRealComparison(ctx, width, height, order, method);
        }
        
        function drawIdealVsRealComparison(ctx, width, height, order, method) {
            const centerY = height * 0.8;
            const freqRange = 10;
            const scaleX = (width - 60) / freqRange;
            const scaleY = height * 0.5;
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(30, centerY);
            ctx.lineTo(width - 30, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(30, 30);
            ctx.lineTo(30, centerY);
            ctx.stroke();
            
            // 绘制理想响应
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            
            const cutoffFreq = 3;
            for (let i = 0; i <= 200; i++) {
                const freq = (i / 200) * freqRange;
                const x = 30 + freq * scaleX;
                const magnitude = freq <= cutoffFreq ? 1 : 0;
                const y = centerY - magnitude * scaleY;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            ctx.setLineDash([]);
            
            // 绘制实际响应
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i <= 200; i++) {
                const freq = (i / 200) * freqRange;
                const x = 30 + freq * scaleX;
                let magnitude = 0;
                
                // 简化的滤波器响应模型
                const s = freq / cutoffFreq;
                switch (method) {
                    case 'butterworth':
                        magnitude = 1 / Math.sqrt(1 + Math.pow(s, 2 * order));
                        break;
                    case 'chebyshev':
                        magnitude = 1 / Math.sqrt(1 + 0.5 * Math.pow(s, 2 * order));
                        break;
                    case 'elliptic':
                        magnitude = s <= 1 ? 1 - 0.1 * Math.sin(order * s) : 0.01;
                        break;
                }
                
                const y = centerY - magnitude * scaleY;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 图例
            ctx.fillStyle = '#3498db';
            ctx.fillRect(width - 150, 50, 20, 3);
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('理想响应', width - 125, 55);
            
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(width - 150, 70, 20, 3);
            ctx.fillText(`实际响应 (${order}阶${method})`, width - 125, 75);
            
            // 标签
            ctx.textAlign = 'center';
            ctx.fillText('频率 (Hz)', width / 2, height - 10);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('幅度', 0, 0);
            ctx.restore();
        }
        
        // 更新设计参数
        function updateDesignParameters() {
            const canvas = document.getElementById('designParameters');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            const fp = parseFloat(document.getElementById('passbandFreq').value);
            const fs = parseFloat(document.getElementById('stopbandFreq').value);
            const rp = parseFloat(document.getElementById('passbandRipple').value);
            const as = parseFloat(document.getElementById('stopbandAtten').value);
            
            document.getElementById('passbandValue').textContent = fp.toFixed(1);
            document.getElementById('stopbandValue').textContent = fs.toFixed(1);
            document.getElementById('rippleValue').textContent = rp.toFixed(1);
            document.getElementById('attenValue').textContent = as;
            
            ctx.clearRect(0, 0, width, height);
            
            drawDesignSpecification(ctx, width, height, fp, fs, rp, as);
        }
        
        function drawDesignSpecification(ctx, width, height, fp, fs, rp, as) {
            const centerY = height * 0.8;
            const freqRange = Math.max(fs * 1.5, 10);
            const scaleX = (width - 60) / freqRange;
            const scaleY = height * 0.6 / 60; // 60dB range
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(30, centerY);
            ctx.lineTo(width - 30, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(30, 30);
            ctx.lineTo(30, centerY);
            ctx.stroke();
            
            // 绘制设计规范区域
            ctx.fillStyle = 'rgba(76, 175, 80, 0.3)'; // 通带区域
            ctx.fillRect(30, centerY - rp * scaleY, fp * scaleX, rp * scaleY);
            
            ctx.fillStyle = 'rgba(244, 67, 54, 0.3)'; // 阻带区域
            ctx.fillRect(30 + fs * scaleX, centerY - as * scaleY, (freqRange - fs) * scaleX, as * scaleY);
            
            // 绘制边界线
            ctx.strokeStyle = '#4caf50';
            ctx.lineWidth = 2;
            
            // 通带上边界
            ctx.beginPath();
            ctx.moveTo(30, centerY);
            ctx.lineTo(30 + fp * scaleX, centerY);
            ctx.stroke();
            
            // 通带下边界
            ctx.beginPath();
            ctx.moveTo(30, centerY - rp * scaleY);
            ctx.lineTo(30 + fp * scaleX, centerY - rp * scaleY);
            ctx.stroke();
            
            // 阻带边界
            ctx.strokeStyle = '#f44336';
            ctx.beginPath();
            ctx.moveTo(30 + fs * scaleX, centerY - as * scaleY);
            ctx.lineTo(width - 30, centerY - as * scaleY);
            ctx.stroke();
            
            // 垂直分界线
            ctx.strokeStyle = '#666';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(30 + fp * scaleX, 30);
            ctx.lineTo(30 + fp * scaleX, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(30 + fs * scaleX, 30);
            ctx.lineTo(30 + fs * scaleX, centerY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // 标注
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            ctx.fillText(`fp=${fp}Hz`, 30 + fp * scaleX, centerY + 20);
            ctx.fillText(`fs=${fs}Hz`, 30 + fs * scaleX, centerY + 20);
            ctx.fillText('频率 (Hz)', width / 2, height - 10);
            
            ctx.textAlign = 'right';
            ctx.fillText(`${rp}dB`, 25, centerY - rp * scaleY + 5);
            ctx.fillText(`${as}dB`, 25, centerY - as * scaleY + 5);
            
            // 区域标签
            ctx.textAlign = 'center';
            ctx.fillStyle = '#4caf50';
            ctx.fillText('通带', 30 + fp * scaleX / 2, centerY - rp * scaleY / 2);
            
            ctx.fillStyle = '#ff9800';
            ctx.fillText('过渡带', 30 + (fp + fs) * scaleX / 2, centerY - 20);
            
            ctx.fillStyle = '#f44336';
            ctx.fillText('阻带', 30 + (fs + freqRange) * scaleX / 2, centerY - as * scaleY / 2);
        }
        
        // 切换答案显示
        function toggleAnswer(answerId) {
            const answer = document.getElementById(answerId);
            answer.style.display = answer.style.display === 'none' ? 'block' : 'none';
        }
        
        // 页面加载后初始化
        window.onload = function() {
            updateFilterDemo();
            demonstrateDistortion();
            compareIdealReal();
            updateDesignParameters();
        };
    </script>
</body>
</html>
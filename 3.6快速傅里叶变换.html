<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>快速傅里叶变换(FFT)</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 30px;
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }
        
        h2 {
            color: #34495e;
            border-left: 4px solid #3498db;
            padding-left: 15px;
            margin-top: 30px;
        }
        
        h3 {
            color: #2980b9;
            margin-top: 25px;
        }
        
        .knowledge-point {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }
        
        .formula {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            font-family: 'Times New Roman', serif;
            font-size: 18px;
        }
        
        .important {
            background: #ffeaa7;
            border: 2px solid #fdcb6e;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .example {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .plot-container {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }
        
        canvas {
            border: 1px solid #ccc;
            margin: 10px;
        }
        
        .controls {
            margin: 15px 0;
            text-align: center;
        }
        
        .controls input, .controls select {
            margin: 5px;
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .controls button {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        
        .controls button:hover {
            background: #2980b9;
        }
        
        .exercise {
            background: #e8f5e8;
            border: 1px solid #c3e6c3;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .exercise h4 {
            color: #2e7d2e;
            margin-top: 0;
        }
        
        .answer {
            background: #f0f0f0;
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
            display: none;
        }
        
        .show-answer {
            background: #28a745;
            color: white;
            border: none;
            padding: 5px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        
        .show-answer:hover {
            background: #218838;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        th {
            background: #f2f2f2;
        }
        
        .highlight {
            background: #ffeb3b;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .problem-box {
            background: #ffebee;
            border: 2px solid #f44336;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .solution-box {
            background: #e8f5e8;
            border: 2px solid #4caf50;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .complexity-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .complexity-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }
        
        .butterfly-demo {
            background: #f0f8ff;
            border: 1px solid #87ceeb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }
        
        .algorithm-steps {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .algorithm-steps ol {
            margin: 0;
            padding-left: 20px;
        }
        
        .flow-graph {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
        }
        
        .stage {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 20px;
        }
        
        .stage-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #2980b9;
        }
        
        .node {
            width: 30px;
            height: 30px;
            border: 2px solid #3498db;
            border-radius: 50%;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .performance-chart {
            background: #fafafa;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>信号分析与处理 - 第六章：快速傅里叶变换(FFT)</h1>
        
        <h2>6.1 直接DFT运算的问题</h2>
        
        <div class="problem-box">
            <h3>🚨 直接DFT计算的计算量问题</h3>
            <p>回顾DFT的定义：</p>
            <div class="formula">
                X[k] = ∑<sub>n=0</sub><sup>N-1</sup> x[n]W<sub>N</sub><sup>kn</sup>, k = 0, 1, ..., N-1
            </div>
            
            <h4>计算复杂度分析：</h4>
            <ul>
                <li><strong>复数乘法次数</strong>：每个X[k]需要N次复数乘法，共N个X[k] → N²次</li>
                <li><strong>复数加法次数</strong>：每个X[k]需要N-1次复数加法，共N个X[k] → N(N-1)次</li>
                <li><strong>总计算量</strong>：O(N²)</li>
            </ul>
            
            <div class="important">
                <h4>实际数据对比</h4>
                <table>
                    <tr>
                        <th>序列长度N</th>
                        <th>直接DFT乘法次数</th>
                        <th>计算时间估计</th>
                    </tr>
                    <tr>
                        <td>64</td>
                        <td>4,096</td>
                        <td>4ms</td>
                    </tr>
                    <tr>
                        <td>1,024</td>
                        <td>1,048,576</td>
                        <td>1s</td>
                    </tr>
                    <tr>
                        <td>4,096</td>
                        <td>16,777,216</td>
                        <td>16s</td>
                    </tr>
                    <tr>
                        <td>65,536</td>
                        <td>4,294,967,296</td>
                        <td>1小时</td>
                    </tr>
                </table>
                <p class="highlight">随着N的增长，计算量呈平方级增长，实际应用中无法接受！</p>
            </div>
        </div>
        
        <h2>6.2 FFT的改进思路</h2>
        
        <div class="solution-box">
            <h3>💡 分治算法的核心思想</h3>
            <p>FFT算法的基本思路是<strong>分治法(Divide and Conquer)</strong>：</p>
            
            <h4>1. 可分性分析</h4>
            <ul>
                <li><strong>问题</strong>：计算N点DFT</li>
                <li><strong>分解</strong>：分解为两个N/2点DFT</li>
                <li><strong>合并</strong>：通过简单运算合并结果</li>
                <li><strong>条件</strong>：N = 2ᵐ（基-2 FFT）</li>
            </ul>
            
            <h4>2. 复杂度分析</h4>
            <div class="formula">
                T(N) = 2T(N/2) + O(N) = O(N log N)
            </div>
            
            <div class="complexity-comparison">
                <div class="complexity-item">
                    <h4>直接DFT</h4>
                    <p><strong>复杂度：O(N²)</strong></p>
                    <p>乘法次数：N²</p>
                    <p>不可实用于大N</p>
                </div>
                <div class="complexity-item">
                    <h4>FFT算法</h4>
                    <p><strong>复杂度：O(N log N)</strong></p>
                    <p>乘法次数：(N/2)log₂N</p>
                    <p>实际应用的基础</p>
                </div>
            </div>
        </div>
        
        <div class="performance-chart">
            <h3>性能对比图表</h3>
            <canvas id="performanceChart" width="800" height="300"></canvas>
        </div>
        
        <h2>6.3 基-2按时间抽取FFT算法（DIT-FFT）</h2>
        
        <div class="knowledge-point">
            <h3>算法基本原理</h3>
            <p><strong>时间抽取(Decimation-in-Time, DIT)</strong>：在时域将输入序列按奇偶分组</p>
            
            <h4>第一步：序列分组</h4>
            <p>将N点序列x[n]分为偶数组和奇数组：</p>
            <div class="formula">
                x₁[r] = x[2r], r = 0, 1, ..., N/2-1 （偶数组）<br>
                x₂[r] = x[2r+1], r = 0, 1, ..., N/2-1 （奇数组）
            </div>
            
            <h4>第二步：DFT分解</h4>
            <div class="formula">
                X[k] = ∑<sub>r=0</sub><sup>N/2-1</sup> x[2r]W<sub>N</sub><sup>2rk</sup> + ∑<sub>r=0</sub><sup>N/2-1</sup> x[2r+1]W<sub>N</sub><sup>(2r+1)k</sup>
            </div>
            
            <h4>第三步：利用旋转因子性质</h4>
            <p>利用 W<sub>N</sub><sup>2</sup> = W<sub>N/2</sub>：</p>
            <div class="formula">
                X[k] = ∑<sub>r=0</sub><sup>N/2-1</sup> x₁[r]W<sub>N/2</sub><sup>rk</sup> + W<sub>N</sub><sup>k</sup>∑<sub>r=0</sub><sup>N/2-1</sup> x₂[r]W<sub>N/2</sub><sup>rk</sup>
            </div>
            
            <h4>第四步：得到递归关系</h4>
            <div class="formula">
                X[k] = X₁[k] + W<sub>N</sub><sup>k</sup>X₂[k]<br>
                X[k + N/2] = X₁[k] - W<sub>N</sub><sup>k</sup>X₂[k]
            </div>
            <p>其中 k = 0, 1, ..., N/2-1</p>
        </div>
        
        <div class="butterfly-demo">
            <h3>🦋 蝶形运算单元</h3>
            <p>FFT的基本计算单元是<strong>蝶形运算(Butterfly Operation)</strong>：</p>
            <canvas id="butterflyDiagram" width="400" height="200"></canvas>
            <div class="formula">
                A' = A + W<sub>N</sub><sup>r</sup> × B<br>
                B' = A - W<sub>N</sub><sup>r</sup> × B
            </div>
            <p><strong>特点：</strong>一次蝶形运算需要1次复数乘法和2次复数加法</p>
        </div>
        
        <div class="algorithm-steps">
            <h3>完整算法步骤</h3>
            <ol>
                <li><strong>位反序排列</strong>：将输入序列按位反序重新排列</li>
                <li><strong>多级蝶形运算</strong>：进行log₂N级蝶形运算</li>
                <li><strong>每级处理</strong>：每级有N/2个蝶形运算单元</li>
                <li><strong>旋转因子更新</strong>：每级的旋转因子按规律变化</li>
            </ol>
        </div>
        
        <div class="plot-container">
            <h3>8点FFT信号流图演示</h3>
            <canvas id="fftFlowGraph" width="800" height="400"></canvas>
            <div class="controls">
                <label>演示点数：</label>
                <select id="fftPoints">
                    <option value="4">4点FFT</option>
                    <option value="8" selected>8点FFT</option>
                    <option value="16">16点FFT</option>
                </select>
                <button onclick="drawFFTFlowGraph()">绘制信号流图</button>
            </div>
        </div>
        
        <h2>6.4 位反序(Bit-Reversal)详解</h2>
        
        <div class="knowledge-point">
            <h3>位反序的必要性</h3>
            <p>由于递归分解的过程，输入序列需要按照<strong>位反序</strong>的顺序排列：</p>
            
            <div class="example">
                <h4>8点FFT位反序示例</h4>
                <table>
                    <tr>
                        <th>原始索引</th>
                        <th>二进制</th>
                        <th>位反序二进制</th>
                        <th>位反序索引</th>
                        <th>输入顺序</th>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td>000</td>
                        <td>000</td>
                        <td>0</td>
                        <td>x[0]</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>001</td>
                        <td>100</td>
                        <td>4</td>
                        <td>x[4]</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>010</td>
                        <td>010</td>
                        <td>2</td>
                        <td>x[2]</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>011</td>
                        <td>110</td>
                        <td>6</td>
                        <td>x[6]</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>100</td>
                        <td>001</td>
                        <td>1</td>
                        <td>x[1]</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>101</td>
                        <td>101</td>
                        <td>5</td>
                        <td>x[5]</td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>110</td>
                        <td>011</td>
                        <td>3</td>
                        <td>x[3]</td>
                    </tr>
                    <tr>
                        <td>7</td>
                        <td>111</td>
                        <td>111</td>
                        <td>7</td>
                        <td>x[7]</td>
                    </tr>
                </table>
            </div>
        </div>
        
        <div class="plot-container">
            <h3>位反序计算器</h3>
            <div class="controls">
                <label>输入序列长度N：</label>
                <select id="bitReversalN">
                    <option value="4">4</option>
                    <option value="8">8</option>
                    <option value="16">16</option>
                    <option value="32">32</option>
                </select>
                <button onclick="generateBitReversal()">生成位反序表</button>
            </div>
            <div id="bitReversalTable" style="margin-top: 15px;"></div>
        </div>
        
        <h2>6.5 FFT算法复杂度分析</h2>
        
        <div class="knowledge-point">
            <h3>详细复杂度计算</h3>
            
            <h4>基-2 DIT-FFT复杂度</h4>
            <ul>
                <li><strong>级数</strong>：log₂N级</li>
                <li><strong>每级蝶形运算数</strong>：N/2个</li>
                <li><strong>每个蝶形运算</strong>：1次复数乘法，2次复数加法</li>
                <li><strong>总复数乘法次数</strong>：(N/2)log₂N</li>
                <li><strong>总复数加法次数</strong>：N log₂N</li>
            </ul>
            
            <div class="important">
                <h4>效率提升对比</h4>
                <table>
                    <tr>
                        <th>N</th>
                        <th>直接DFT</th>
                        <th>FFT</th>
                        <th>提升倍数</th>
                    </tr>
                    <tr>
                        <td>64</td>
                        <td>4,096</td>
                        <td>192</td>
                        <td>21.3</td>
                    </tr>
                    <tr>
                        <td>1,024</td>
                        <td>1,048,576</td>
                        <td>5,120</td>
                        <td>204.8</td>
                    </tr>
                    <tr>
                        <td>4,096</td>
                        <td>16,777,216</td>
                        <td>24,576</td>
                        <td>682.7</td>
                    </tr>
                    <tr>
                        <td>65,536</td>
                        <td>4,294,967,296</td>
                        <td>524,288</td>
                        <td>8,192</td>
                    </tr>
                </table>
            </div>
        </div>
        
        <div class="plot-container">
            <h3>FFT vs 直接DFT性能对比</h3>
            <canvas id="complexityComparison" width="800" height="400"></canvas>
        </div>
        
        <h2>6.6 FFT实现示例</h2>
        
        <div class="plot-container">
            <h3>FFT计算器</h3>
            <canvas id="fftCalculator" width="800" height="300"></canvas>
            <div class="controls">
                <label>输入序列(实部,用逗号分隔)：</label>
                <input type="text" id="fftInput" value="1,1,0,0,0,0,0,0" placeholder="例: 1,1,0,0,0,0,0,0">
                <button onclick="calculateFFT()">计算FFT</button>
                <button onclick="compareWithDFT()">与DFT对比</button>
            </div>
            <div id="fftResult" style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px;"></div>
        </div>
        
        <h2>练习题目</h2>
        
        <div class="exercise">
            <h4>练习1：位反序排列</h4>
            <p>对于16点FFT，写出输入序列x[0], x[1], ..., x[15]的位反序排列顺序</p>
            <button class="show-answer" onclick="toggleAnswer('answer1')">显示答案</button>
            <div id="answer1" class="answer">
                <strong>答案：</strong><br>
                位反序后的顺序为：<br>
                x[0], x[8], x[4], x[12], x[2], x[10], x[6], x[14], x[1], x[9], x[5], x[13], x[3], x[11], x[7], x[15]
            </div>
        </div>
        
        <div class="exercise">
            <h4>练习2：蝶形运算</h4>
            <p>在8点FFT的第2级中，计算以下蝶形运算：</p>
            <p>A = 2+j, B = 1-j, 旋转因子 W₈² = -j</p>
            <p>求输出 A' 和 B'</p>
            <button class="show-answer" onclick="toggleAnswer('answer2')">显示答案</button>
            <div id="answer2" class="answer">
                <strong>答案：</strong><br>
                A' = A + W₈² × B = (2+j) + (-j) × (1-j) = (2+j) + (-j+j²) = (2+j) + (-j-1) = 1<br>
                B' = A - W₈² × B = (2+j) - (-j-1) = (2+j) + (j+1) = 3+2j
            </div>
        </div>
        
        <div class="exercise">
            <h4>练习3：复杂度计算</h4>
            <p>计算1024点FFT和直接DFT的复数乘法次数，并求出FFT的加速比</p>
            <button class="show-answer" onclick="toggleAnswer('answer3')">显示答案</button>
            <div id="answer3" class="answer">
                <strong>答案：</strong><br>
                直接DFT：N² = 1024² = 1,048,576次<br>
                FFT：(N/2)log₂N = 512 × 10 = 5,120次<br>
                加速比：1,048,576 ÷ 5,120 = 204.8倍
            </div>
        </div>
        
        <div class="exercise">
            <h4>练习4：算法分析</h4>
            <p>为什么基-2 FFT要求序列长度N = 2ᵐ？如果N不是2的幂次，如何处理？</p>
            <button class="show-answer" onclick="toggleAnswer('answer4')">显示答案</button>
            <div id="answer4" class="answer">
                <strong>答案：</strong><br>
                1. 基-2 FFT通过递归地将N点DFT分解为两个N/2点DFT，要求N能被2整除m次<br>
                2. 如果N不是2的幂次，可以：<br>
                   - 补零到下一个2的幂次<br>
                   - 使用混合基FFT（如基-4、基-8）<br>
                   - 使用素因数分解的FFT算法
            </div>
        </div>
        
        <h2>6.7 学习要点总结</h2>
        
        <div class="important">
            <h3>🎯 FFT核心要点</h3>
            <ol>
                <li><strong>动机理解</strong>：直接DFT的O(N²)复杂度在实际中不可接受</li>
                <li><strong>分治思想</strong>：递归分解是FFT的核心算法思想</li>
                <li><strong>蝶形运算</strong>：FFT的基本计算单元，体现算法精髓</li>
                <li><strong>位反序</strong>：输入数据的重新排列，算法实现的关键</li>
                <li><strong>复杂度优势</strong>：从O(N²)降到O(N log N)的巨大提升</li>
                <li><strong>实际意义</strong>：使大规模数字信号处理成为可能</li>
                <li><strong>算法变种</strong>：DIT、DIF、混合基等多种形式</li>
            </ol>
        </div>
        
        <div class="solution-box">
            <h3>🚀 FFT的历史意义</h3>
            <p>1965年Cooley-Tukey发表的FFT算法被誉为"20世纪最重要的算法之一"，它：</p>
            <ul>
                <li>使数字信号处理从理论走向实用</li>
                <li>推动了数字音频、图像处理的发展</li>
                <li>成为现代通信系统的基础算法</li>
                <li>奠定了谱分析、滤波器设计的计算基础</li>
            </ul>
        </div>
    </div>

    <script>
        // 绘制性能对比图表
        function drawPerformanceChart() {
            const canvas = document.getElementById('performanceChart');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // 坐标系设置
            const margin = 60;
            const plotWidth = width - 2 * margin;
            const plotHeight = height - 2 * margin;
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            // x轴
            ctx.beginPath();
            ctx.moveTo(margin, height - margin);
            ctx.lineTo(width - margin, height - margin);
            ctx.stroke();
            
            // y轴
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, height - margin);
            ctx.stroke();
            
            // 数据点
            const nValues = [4, 8, 16, 32, 64, 128, 256, 512, 1024];
            const dftComplexity = nValues.map(n => n * n);
            const fftComplexity = nValues.map(n => n * Math.log2(n));
            
            // 归一化
            const maxDFT = Math.max(...dftComplexity);
            const maxFFT = Math.max(...fftComplexity);
            const maxVal = Math.max(maxDFT, maxFFT);
            
            // 绘制DFT曲线
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            dftComplexity.forEach((val, index) => {
                const x = margin + (index / (nValues.length - 1)) * plotWidth;
                const y = height - margin - (val / maxVal) * plotHeight;
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // 绘制FFT曲线
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            fftComplexity.forEach((val, index) => {
                const x = margin + (index / (nValues.length - 1)) * plotWidth;
                const y = height - margin - (val / maxVal) * plotHeight;
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // 标签和图例
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('序列长度 N', width / 2, height - 10);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('计算复杂度', 0, 0);
            ctx.restore();
            
            // 图例
            ctx.fillStyle = 'red';
            ctx.fillRect(width - 150, 30, 20, 3);
            ctx.fillStyle = '#333';
            ctx.textAlign = 'left';
            ctx.fillText('直接DFT: O(N²)', width - 125, 35);
            
            ctx.fillStyle = 'blue';
            ctx.fillRect(width - 150, 50, 20, 3);
            ctx.fillStyle = '#333';
            ctx.fillText('FFT: O(N log N)', width - 125, 55);
            
            // x轴刻度
            nValues.forEach((n, index) => {
                const x = margin + (index / (nValues.length - 1)) * plotWidth;
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.fillText(n.toString(), x, height - margin + 20);
            });
        }
        
        // 绘制蝶形运算图
        function drawButterflyDiagram() {
            const canvas = document.getElementById('butterflyDiagram');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const inputY1 = centerY - 40;
            const inputY2 = centerY + 40;
            const outputY1 = centerY - 40;
            const outputY2 = centerY + 40;
            const leftX = 50;
            const rightX = width - 50;
            
            // 绘制输入输出点
            ctx.fillStyle = '#3498db';
            ctx.beginPath();
            ctx.arc(leftX, inputY1, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(leftX, inputY2, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(rightX, outputY1, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(rightX, outputY2, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            // 绘制连线
            ctx.strokeStyle = '#2980b9';
            ctx.lineWidth = 2;
            
            // 直线连接
            ctx.beginPath();
            ctx.moveTo(leftX + 8, inputY1);
            ctx.lineTo(rightX - 8, outputY1);
            ctx.stroke();
            
            // 交叉连接
            ctx.beginPath();
            ctx.moveTo(leftX + 8, inputY2);
            ctx.lineTo(rightX - 8, outputY1);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(leftX + 8, inputY1);
            ctx.lineTo(rightX - 8, outputY2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(leftX + 8, inputY2);
            ctx.lineTo(rightX - 8, outputY2);
            ctx.stroke();
            
            // 标记旋转因子
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('W^r', centerX, centerY - 20);
            ctx.fillText('-W^r', centerX, centerY + 30);
            
            // 输入输出标签
            ctx.textAlign = 'right';
            ctx.fillText('A', leftX - 15, inputY1 + 5);
            ctx.fillText('B', leftX - 15, inputY2 + 5);
            
            ctx.textAlign = 'left';
            ctx.fillText("A'", rightX + 15, outputY1 + 5);
            ctx.fillText("B'", rightX + 15, outputY2 + 5);
        }
        
        // 绘制FFT信号流图
        function drawFFTFlowGraph() {
            const canvas = document.getElementById('fftFlowGraph');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const N = parseInt(document.getElementById('fftPoints').value);
            
            ctx.clearRect(0, 0, width, height);
            
            if (N !== 8) {
                ctx.fillStyle = '#333';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${N}点FFT信号流图（简化显示）`, width/2, height/2);
                return;
            }
            
            // 8点FFT详细信号流图
            const stages = 4; // 输入 + 3级运算
            const stageWidth = width / stages;
            const nodeHeight = height / (N + 1);
            
            // 绘制各级
            for (let stage = 0; stage < stages; stage++) {
                const x = stageWidth * (stage + 0.5);
                
                // 绘制节点
                for (let i = 0; i < N; i++) {
                    const y = nodeHeight * (i + 1);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, 2 * Math.PI);
                    ctx.fillStyle = stage === 0 ? '#3498db' : (stage === stages - 1 ? '#e74c3c' : '#95a5a6');
                    ctx.fill();
                    ctx.strokeStyle = '#2c3e50';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // 标签
                    if (stage === 0) {
                        ctx.fillStyle = '#333';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        const bitReversed = bitReverse(i, 3);
                        ctx.fillText(`x[${bitReversed}]`, x, y - 15);
                    } else if (stage === stages - 1) {
                        ctx.fillStyle = '#333';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`X[${i}]`, x, y - 15);
                    }
                }
                
                // 绘制级间连线（简化）
                if (stage < stages - 1) {
                    ctx.strokeStyle = '#7f8c8d';
                    ctx.lineWidth = 1;
                    
                    for (let i = 0; i < N; i += 2) {
                        const y1 = nodeHeight * (i + 1);
                        const y2 = nodeHeight * (i + 2);
                        const x1 = stageWidth * (stage + 0.5) + 8;
                        const x2 = stageWidth * (stage + 1.5) - 8;
                        
                        // 直连
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y1);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y2);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                        
                        // 交叉连接
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y2);
                        ctx.lineTo(x2, y1);
                        ctx.stroke();
                    }
                }
            }
            
            // 级标题
            const stageNames = ['输入', '第1级', '第2级', '输出'];
            stageNames.forEach((name, index) => {
                ctx.fillStyle = '#2980b9';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(name, stageWidth * (index + 0.5), 25);
            });
        }
        
        // 位反序函数
        function bitReverse(num, bits) {
            let result = 0;
            for (let i = 0; i < bits; i++) {
                result = (result << 1) | (num & 1);
                num >>= 1;
            }
            return result;
        }
        
        // 生成位反序表
        function generateBitReversal() {
            const N = parseInt(document.getElementById('bitReversalN').value);
            const bits = Math.log2(N);
            
            let tableHTML = '<h4>位反序对照表</h4>';
            tableHTML += '<table style="width: 100%; border-collapse: collapse;">';
            tableHTML += '<tr><th>原索引</th><th>二进制</th><th>位反序二进制</th><th>位反序索引</th></tr>';
            
            for (let i = 0; i < N; i++) {
                const binary = i.toString(2).padStart(bits, '0');
                const reversedBinary = binary.split('').reverse().join('');
                const reversedIndex = parseInt(reversedBinary, 2);
                
                tableHTML += `<tr>
                    <td>${i}</td>
                    <td>${binary}</td>
                    <td>${reversedBinary}</td>
                    <td>${reversedIndex}</td>
                </tr>`;
            }
            
            tableHTML += '</table>';
            document.getElementById('bitReversalTable').innerHTML = tableHTML;
        }
        
        // 绘制复杂度对比图
        function drawComplexityComparison() {
            const canvas = document.getElementById('complexityComparison');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // 坐标系设置
            const margin = 60;
            const plotWidth = width - 2 * margin;
            const plotHeight = height - 2 * margin;
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            // x轴
            ctx.beginPath();
            ctx.moveTo(margin, height - margin);
            ctx.lineTo(width - margin, height - margin);
            ctx.stroke();
            
            // y轴（对数坐标）
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, height - margin);
            ctx.stroke();
            
            // 数据
            const nValues = [];
            const dftOps = [];
            const fftOps = [];
            
            for (let n = 4; n <= 1024; n *= 2) {
                nValues.push(n);
                dftOps.push(n * n);
                fftOps.push(n * Math.log2(n) / 2);
            }
            
            // 对数化
            const logDFT = dftOps.map(x => Math.log10(x));
            const logFFT = fftOps.map(x => Math.log10(x));
            const maxLog = Math.max(...logDFT);
            const minLog = Math.min(...logFFT);
            
            // 绘制曲线
            function drawCurve(data, color, label) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                data.forEach((val, index) => {
                    const x = margin + (index / (data.length - 1)) * plotWidth;
                    const y = height - margin - ((val - minLog) / (maxLog - minLog)) * plotHeight;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // 绘制点
                ctx.fillStyle = color;
                data.forEach((val, index) => {
                    const x = margin + (index / (data.length - 1)) * plotWidth;
                    const y = height - margin - ((val - minLog) / (maxLog - minLog)) * plotHeight;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }
            
            drawCurve(logDFT, '#e74c3c', 'DFT');
            drawCurve(logFFT, '#3498db', 'FFT');
            
            // 标签
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('序列长度 N', width / 2, height - 10);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('运算次数 (log₁₀)', 0, 0);
            ctx.restore();
            
            // 图例
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(width - 150, 30, 20, 3);
            ctx.fillStyle = '#333';
            ctx.textAlign = 'left';
            ctx.fillText('直接DFT', width - 125, 35);
            
            ctx.fillStyle = '#3498db';
            ctx.fillRect(width - 150, 50, 20, 3);
            ctx.fillText('FFT', width - 125, 55);
            
            // x轴刻度
            nValues.forEach((n, index) => {
                const x = margin + (index / (nValues.length - 1)) * plotWidth;
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.fillText(n.toString(), x, height - margin + 20);
            });
        }
        
        // 简单FFT实现（用于演示）
        function simpleFFT(x) {
            const N = x.length;
            if (N <= 1) return x;
            
            // 位反序
            const bitReversed = new Array(N);
            const bits = Math.log2(N);
            for (let i = 0; i < N; i++) {
                bitReversed[bitReverse(i, bits)] = x[i];
            }
            
            // 蝶形运算
            for (let len = 2; len <= N; len *= 2) {
                const step = len / 2;
                for (let i = 0; i < N; i += len) {
                    for (let j = 0; j < step; j++) {
                        const u = bitReversed[i + j];
                        const v = bitReversed[i + j + step];
                        const w = {
                            real: Math.cos(-2 * Math.PI * j / len),
                            imag: Math.sin(-2 * Math.PI * j / len)
                        };
                        
                        // 复数乘法 v * w
                        const temp = {
                            real: v.real * w.real - v.imag * w.imag,
                            imag: v.real * w.imag + v.imag * w.real
                        };
                        
                        bitReversed[i + j] = {
                            real: u.real + temp.real,
                            imag: u.imag + temp.imag
                        };
                        
                        bitReversed[i + j + step] = {
                            real: u.real - temp.real,
                            imag: u.imag - temp.imag
                        };
                    }
                }
            }
            
            return bitReversed;
        }
        
        // 计算FFT
        function calculateFFT() {
            const input = document.getElementById('fftInput').value;
            const sequence = input.split(',').map(x => ({
                real: parseFloat(x.trim()) || 0,
                imag: 0
            })).filter(x => !isNaN(x.real));
            
            if (sequence.length === 0 || (sequence.length & (sequence.length - 1)) !== 0) {
                document.getElementById('fftResult').innerHTML = '<span style="color: red;">请输入长度为2的幂次的有效序列！</span>';
                return;
            }
            
            const result = simpleFFT(sequence);
            
            // 显示结果
            let resultHTML = '<h4>FFT计算结果：</h4>';
            resultHTML += '<table style="width: 100%; border-collapse: collapse;">';
            resultHTML += '<tr><th>k</th><th>实部</th><th>虚部</th><th>幅度</th><th>相位(度)</th></tr>';
            
            result.forEach((coeff, k) => {
                const magnitude = Math.sqrt(coeff.real * coeff.real + coeff.imag * coeff.imag);
                const phase = Math.atan2(coeff.imag, coeff.real) * 180 / Math.PI;
                resultHTML += `<tr>
                    <td>${k}</td>
                    <td>${coeff.real.toFixed(3)}</td>
                    <td>${coeff.imag.toFixed(3)}</td>
                    <td>${magnitude.toFixed(3)}</td>
                    <td>${phase.toFixed(1)}°</td>
                </tr>`;
            });
            
            resultHTML += '</table>';
            document.getElementById('fftResult').innerHTML = resultHTML;
            
            // 绘制结果
            plotFFTResult(result);
        }
        
        // 绘制FFT结果
        function plotFFTResult(result) {
            const canvas = document.getElementById('fftCalculator');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            const centerY = height * 0.8;
            const scaleX = (width - 60) / (result.length + 1);
            const magnitudes = result.map(c => Math.sqrt(c.real * c.real + c.imag * c.imag));
            const maxMag = Math.max(...magnitudes) || 1;
            const scaleY = (height * 0.5) / maxMag;
            
            // 坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(30, centerY);
            ctx.lineTo(width - 30, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(50, 20);
            ctx.lineTo(50, height - 20);
            ctx.stroke();
            
            // 绘制频谱
            ctx.strokeStyle = '#e74c3c';
            ctx.fillStyle = '#e74c3c';
            ctx.lineWidth = 2;
            
            magnitudes.forEach((mag, index) => {
                const x = 50 + (index + 1) * scaleX;
                const y = centerY - mag * scaleY;
                
                // 茎
                ctx.beginPath();
                ctx.moveTo(x, centerY);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                // 点
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
                
                // 标记
                if (index % Math.ceil(result.length / 8) === 0) {
                    ctx.fillStyle = '#333';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(index.toString(), x, centerY + 15);
                    ctx.fillStyle = '#e74c3c';
                }
            });
            
            // 标题
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('FFT幅度谱', width / 2, 15);
        }
        
        // 与DFT对比
        function compareWithDFT() {
            const input = document.getElementById('fftInput').value;
            const sequence = input.split(',').map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
            
            if (sequence.length === 0) return;
            
            // 补零到2的幂次
            let N = 1;
            while (N < sequence.length) N *= 2;
            while (sequence.length < N) sequence.push(0);
            
            const start = performance.now();
            
            // 计算FFT
            const fftInput = sequence.map(x => ({real: x, imag: 0}));
            const fftResult = simpleFFT(fftInput);
            const fftTime = performance.now() - start;
            
            // 计算直接DFT（用于对比）
            const dftStart = performance.now();
            const dftResult = calculateDFTDirect(sequence);
            const dftTime = performance.now() - dftStart;
            
            // 显示对比结果
            let compareHTML = '<h4>FFT vs DFT性能对比：</h4>';
            compareHTML += `<p>序列长度：${N}</p>`;
            compareHTML += `<p>FFT计算时间：${fftTime.toFixed(3)} ms</p>`;
            compareHTML += `<p>DFT计算时间：${dftTime.toFixed(3)} ms</p>`;
            compareHTML += `<p>加速比：${(dftTime / fftTime).toFixed(1)}x</p>`;
            
            document.getElementById('fftResult').innerHTML = compareHTML;
        }
        
        // 直接DFT计算
        function calculateDFTDirect(x) {
            const N = x.length;
            const X = [];
            
            for (let k = 0; k < N; k++) {
                let real = 0;
                let imag = 0;
                
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    real += x[n] * Math.cos(angle);
                    imag += x[n] * Math.sin(angle);
                }
                
                X.push({real: real, imag: imag});
            }
            
            return X;
        }
        
        // 切换答案显示
        function toggleAnswer(answerId) {
            const answer = document.getElementById(answerId);
            answer.style.display = answer.style.display === 'none' ? 'block' : 'none';
        }
        
        // 页面加载后初始化
        window.onload = function() {
            drawPerformanceChart();
            drawButterflyDiagram();
            drawFFTFlowGraph();
            generateBitReversal();
            drawComplexityComparison();
            calculateFFT();
        };
    </script>
</body>
</html>